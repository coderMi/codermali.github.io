<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://codermali.github.io/malideLibrary.github.io/</id>
    <title>malide Library</title>
    <updated>2019-07-11T18:46:16.411Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://codermali.github.io/malideLibrary.github.io/"/>
    <link rel="self" href="https://codermali.github.io/malideLibrary.github.io//atom.xml"/>
    <logo>https://codermali.github.io/malideLibrary.github.io//images/avatar.png</logo>
    <icon>https://codermali.github.io/malideLibrary.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, malide Library</rights>
    <entry>
        <title type="html"><![CDATA[iOS State Restoration]]></title>
        <id>https://codermali.github.io/malideLibrary.github.io//post/ios-state-restoration</id>
        <link href="https://codermali.github.io/malideLibrary.github.io//post/ios-state-restoration">
        </link>
        <updated>2019-06-24T17:35:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>最近项目中碰到了一个问题：由于编辑器占用内存过多，导致APP进入后台之后，很快就会被杀掉。这个时候，如果用户正在使用编辑器，那么编辑器里面的内容就会丢失了。针对这个问题，我想到了几个解决方案。</p>
<ol>
<li>通过后台播放无声音乐，请求定位等方式让APP在后台长时间留存。不过跟群友交流过之后，发现很大的可能不会过审，放弃。（后来又有群友说后台播放无声音乐是可以通过审核的，没有证实。）</li>
<li>添加草稿功能。实时本地（云端）保存编辑器中的内容，重新进入编辑器之后加载缓存。这样就又有几个问题。首先，是否需要本地缓存APP被杀掉时的页面，在APP重新启动时，根据缓存的路径，进入页面。这样的话就需要对页面的路径进行配置、判断，想想就很麻烦；第二，是项目中有多个编辑器，编辑器中内容可能非常多，使用轻量级的plist、NSUserDefaults、NSKeyedAchiever等可能不是很合适，使用数据库又觉得没必要。</li>
</ol>
<p>在这个时候，偶然发现 Apple 针对本身的伪后台系统，提供了一套API，让我们来恢复在后台被杀掉的APP的状态。那就是<code>UIStateRestoration</code>。</p>
<h3 id="app-state-restoration简介"><code>APP State Restoration</code>简介</h3>
<p>由于iOS系统的设计，APP在后台停留时间过长，就很有可能被杀掉。然而，为了更好的体验，我们是希望APP可以一直停留在后台的。为了弥补这一点，在iOS 6.0版本之后，为我们一共了一套API，让我们可以在APP在后台被杀掉之后，重新启动APP时，可以恢复到APP被杀掉之前的状态。</p>
<h3 id="api介绍部分">API介绍（部分。。。）</h3>
<pre><code>@protocol UIViewControllerRestoration  //必须实现。
//这个方法使用来创建或者找到相关的viewController。如果返回为nil，那么就不会恢复该viewController以及它的子视图。
+ (nullable UIViewController *) viewControllerWithRestorationIdentifierPath:(NSArray&lt;NSString *&gt; *)identifierComponents coder:(NSCoder *)coder;
@end

//这个协议是用来恢复UITableVie和UICollectionView的数据
@protocol UIDataSourceModelAssociation
- (nullable NSString *) modelIdentifierForElementAtIndexPath:(NSIndexPath *)idx inView:(UIView *)view;
- (nullable NSIndexPath *) indexPathForElementWithModelIdentifier:(NSString *)identifier inView:(UIView *)view;
@end

#pragma mark -- State Restoration object protocols and methods --

@protocol UIObjectRestoration;

@protocol UIStateRestoring &lt;NSObject&gt;
@optional

@property (nonatomic, readonly, nullable) id&lt;UIStateRestoring&gt; restorationParent;

@property (nonatomic, readonly, nullable) Class&lt;UIObjectRestoration&gt; objectRestorationClass;

//这两个方式是用来保存和恢复当前页面中需要保存的数据的。
- (void) encodeRestorableStateWithCoder:(NSCoder *)coder;
- (void) decodeRestorableStateWithCoder:(NSCoder *)coder;

//在所有的数据都恢复之后执行。
- (void) applicationFinishedRestoringState;
@end

@protocol UIObjectRestoration
+ (nullable id&lt;UIStateRestoring&gt;) objectWithRestorationIdentifierPath:(NSArray&lt;NSString *&gt; *)identifierComponents coder:(NSCoder *)coder;
@end
</code></pre>
<p>###API使用
在实际的使用中，分为两种情况。</p>
<ol>
<li><code>以UINavigationController</code>为根控制器。因为<code>UINavigationController</code>会自动记录子视图的层级，因此非常容易实现，这里不多说。Apple官方的demo也是基于<code>UINavigationController</code>的。</li>
<li>以<code>UITableViewController</code>为根控制器。<code>UITableViewController</code>不会记录子视图的层级，因此需要对自己来定义。</li>
</ol>
<p>在这里，我们基于<code>UITableViewController</code>和<code>UINavigationController</code>为构架的普通APP为例子实现APP状态的恢复。</p>
<h5 id="一-首先需要实现appdelegate的两个方法">一、首先需要实现APPDelegate的两个方法。</h5>
<pre><code>/**
该方法在APP进入后台，或者在前台被用户主动杀掉时执行。（如果被系统杀掉，或者用户在后台杀掉，则不会执行）。返回`YES`，通知APPDelegate，在APP进入后台时，需要保存
State。
*/
- (BOOL)application:(UIApplication *)application shouldSaveApplicationState:(NSCoder *)coder {
    return YES;
}

/**
如果APP是异常关闭（后台被杀等），那么在下一次启动时，会执行这个方法。返回`YES`，通知APPDelegate，保存的状态需要被恢复。执行顺序为：
[AppDelegate application:willFinishLaunchingWithOptions:]
[AppDelegate application:shouldRestoreApplicationState:]
[AppDelegate application:didFinishLaunchingWithOptions:]
*/
- (BOOL)application:(UIApplication *)application shouldRestoreApplicationState:(NSCoder *)coder {
    return YES;
}
</code></pre>
<h5 id="二-需要在appdelegate-applicationdidfinishlaunchingwithoptions方法中进行处理并实现appdelegate-applicationwillfinishlaunchingwithoptions方法">二、需要在<code>[AppDelegate application:didFinishLaunchingWithOptions:]</code>方法中进行处理，并实现<code>[AppDelegate application:willFinishLaunchingWithOptions:]</code>方法。</h5>
<pre><code>- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    
    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
    
    return YES;
}


- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {

    if (!self.window.rootViewController) {
        TabBarController *tabBarC = [[TabBarController alloc] init];
        self.window.rootViewController = tabBarC;
    }
    [self.window makeKeyAndVisible];
    
    return YES;
}
</code></pre>
<h5 id="三-根控制器uitableviewcontroller遵守并实现协议">三、根控制器<code>UITableViewController</code>遵守并实现协议。</h5>
<pre><code>#import &quot;TabBarController.h&quot;

@interface TabBarController ()&lt;UIViewControllerRestoration&gt;

@end

@implementation TabBarController

+ (UIViewController *)viewControllerWithRestorationIdentifierPath:(NSArray&lt;NSString *&gt; *)identifierComponents coder:(NSCoder *)coder {

    TabBarController *tabBarC = [[TabBarController alloc] init];
    [[UIApplication sharedApplication] delegate].window.rootViewController = tabBarC;
    
    return tabBarC;
}

@end
</code></pre>
<h5 id="四-uinavigationcontroller准守并实现协议">四、<code>UINavigationController</code>准守并实现协议。</h5>
<pre><code>#import &quot;NavigationController.h&quot;
#import &quot;TabBarController.h&quot;
#import &quot;HomeController.h&quot;
#import &quot;DynamicController.h&quot;
#import &quot;MineController.h&quot;

@interface NavigationController ()&lt;UIViewControllerRestoration&gt;

@end

@implementation NavigationController

- (instancetype)initWithRootViewController:(UIViewController *)rootViewController {
    if (self = [super initWithRootViewController:rootViewController]) {
        
        UIViewController *viewController = self.viewControllers.firstObject;
        if ([viewController isKindOfClass:[HomeController class]]) {
            self.restorationIdentifier = @&quot;home&quot;;
        }
        if ([viewController isKindOfClass:[DynamicController class]]) {
            self.restorationIdentifier = @&quot;dynamic&quot;;
        }
        if ([viewController isKindOfClass:[MineController class]]) {
            self.restorationIdentifier = @&quot;mine&quot;;
        }
        
        self.restorationClass = [self class];
    }
    return self;
}


+ (UIViewController *)viewControllerWithRestorationIdentifierPath:(NSArray&lt;NSString *&gt; *)identifierComponents coder:(NSCoder *)coder {

    TabBarController *tabBarC = (TabBarController *)[[UIApplication sharedApplication] delegate].window.rootViewController;
    
    NSString *identifier = identifierComponents.lastObject;
    NavigationController *navigationC = nil;
    if ([identifier isEqualToString:@&quot;home&quot;]) {
        navigationC = (NavigationController *)tabBarC.viewControllers[0];
    }
    else if ([identifier isEqualToString:@&quot;dynamic&quot;]) {
        navigationC = (NavigationController *)tabBarC.viewControllers[1];
    }
    else if ([identifier isEqualToString:@&quot;mine&quot;]) {
        navigationC = (NavigationController *)tabBarC.viewControllers[2];
    }
    
    return navigationC;
}

@end
</code></pre>
<h5 id="五-uinavigationcontroller的根控制器遵守并实现协议">五、<code>UINavigationController</code>的根控制器遵守并实现协议</h5>
<pre><code>#import &quot;HomeController.h&quot;

@interface HomeController ()&lt;UIViewControllerRestoration&gt;

@end

@implementation HomeController

- (instancetype)init {
    if (self = [super init]) {
        self.restorationIdentifier = NSStringFromClass([self class]);
        self.restorationClass = [self class];
    }
    return self;
}


+ (UIViewController *)viewControllerWithRestorationIdentifierPath:(NSArray&lt;NSString *&gt; *)identifierComponents coder:(NSCoder *)coder {
//    UITabBarController *rootViewController = (TabBarController *)[UIApplication sharedApplication].delegate.window.rootViewController;

    TabBarController *tabBarC = (TabBarController *)[[UIApplication sharedApplication] delegate].window.rootViewController;
    NavigationController *navigationC = (NavigationController *)tabBarC.viewControllers[0];
    HomeController *homeC = [navigationC.viewControllers firstObject];
    
    return homeC;
}


- (void)encodeRestorableStateWithCoder:(NSCoder *)coder {
    [super encodeRestorableStateWithCoder:coder];
    
}


- (void)decodeRestorableStateWithCoder:(NSCoder *)coder {
    [super decodeRestorableStateWithCoder:coder];
    
}

@end
</code></pre>
<h5 id="六-要恢复的视图遵守并实现协议">六、要恢复的视图遵守并实现协议</h5>
<pre><code>#import &quot;HomeDetailController.h&quot;

@interface HomeDetailController ()&lt;UIViewControllerRestoration&gt;

@end

@implementation HomeDetailController

- (instancetype)init {
    if (self = [super init]) {
        self.restorationIdentifier = NSStringFromClass([self class]);
        self.restorationClass = [self class];
    }
    return self;
}


+ (UIViewController *)viewControllerWithRestorationIdentifierPath:(NSArray&lt;NSString *&gt; *)identifierComponents coder:(NSCoder *)coder {
    return [[self alloc] init];
}


- (void)encodeRestorableStateWithCoder:(NSCoder *)coder {
    [super encodeRestorableStateWithCoder:coder];
}


- (void)decodeRestorableStateWithCoder:(NSCoder *)coder {
    [super decodeRestorableStateWithCoder:coder];
}


- (void)applicationFinishedRestoringState {
}
</code></pre>
<p>到这里，基本上就实现了APP状态的恢复功能。不过还有一些小问题。如果是自定义了<code>UINavigationController</code>，在<code>[UINavigationController pushViewController:animated:]</code>方法中『自定义导航条返回按钮』，设置『跳转时隐藏底部导航条（hidesBottomBarWhenPushed）』等，那么在恢复APP状态之后，这些都会失效。因为在恢复状态的过程中，并没有调用<code>[UINavigationController pushViewController:animated:]</code>方法。目前我没有太好的解决办法，只能在自定义的基类中代码实现再次实现『自定义导航条返回按钮』等功能。</p>
<p>赶时间的碰到看到这里就可以停止了。接下来主要是根据我的理解，解析一下恢复状态的过程。有兴趣的朋友可以看一下。</p>
<h4 id="参考文章">参考文章</h4>
<p><a href="https://www.jianshu.com/p/0b11bcffa115">如何实现UITabbarController 的State Restoration?</a></p>
<p><a href="https://www.jianshu.com/p/66940242d4e9">另类的&quot;APP常驻&quot;——UIStateRestoration</a></p>
<p><a href="https://www.jianshu.com/p/7f2fe9361f07">iOS的App实现状态恢复</a></p>
<p><a href="https://www.jianshu.com/p/b1bbf01f2596">保存和恢复App的状态</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac 系统重装指南]]></title>
        <id>https://codermali.github.io/malideLibrary.github.io//post/mac-xi-tong-chong-zhuang-zhi-nan</id>
        <link href="https://codermali.github.io/malideLibrary.github.io//post/mac-xi-tong-chong-zhuang-zhi-nan">
        </link>
        <updated>2019-06-24T11:02:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mac-系统重装指南">Mac 系统重装指南</h1>
<h2 id="前言">前言</h2>
<p>最近公司入职了一个新的iOS开发，趁着这个时机，把旧电脑安排给了新员工，然后换了一台新 MacBook Pro。这样，就涉及到资料的备份和转移，还好以往我把公司资料直接保存在icloud，这就省了很多时间。但是除了资料，mac上的开发环境、配置等等就需要重新配置了。</p>
<p>回想一下，重装电脑很多次了，每次都要查资料，重新配置。一方面是太麻烦了，另一方面，这样也会把自己很多配置文件丢失，比如：Xcode中的snips，ssh方面的常用的服务器，git和svn中的配置等等。因此希望将这次系统重装流程记录下来，并建立一个备份的资料库，作为自己的积累。</p>
<p>本文基于 <strong>macOS 10.14.5</strong> 。</p>
<h2 id="1-重装系统">1、重装系统</h2>
<h4 id="11-macos-恢复系统">1.1 macOS 恢复系统</h4>
<p>mac开机时有根据不同的命令，可以分别进入不同的模式。(参考<a href="https://support.apple.com/zh-cn/HT201255">Mac 的启动组合键</a>)。</p>
<ul>
<li>
<p><strong>command + r</strong></p>
<ul>
<li>进入内置的 <strong>macOS 恢复系统</strong>。只有在系统恢复盘还存在的时候使用。安装您的 Mac 上装有的最新 macOS。</li>
</ul>
</li>
<li>
<p><strong>command + option + r</strong></p>
<ul>
<li>进入内置的 <strong>macOS 恢复系统</strong>。即使系统恢复盘报废，也可以恢复系统。升级到与您的 Mac 兼容的最新 macOS。</li>
</ul>
</li>
<li>
<p><strong>command + shift + option + r</strong></p>
<ul>
<li>进入内置的 <strong>macOS 恢复系统</strong>。即使系统恢复盘报废，也可以恢复系统。安装 Mac 随附的 macOS 或与它最接近且仍在提供的版本。</li>
</ul>
</li>
<li>
<p><strong>option</strong></p>
<ul>
<li>进入 <strong>启动管理器</strong>。如果该电脑安装了多个系统，那么就可以在这里选择启动盘。</li>
</ul>
</li>
<li>
<p><strong>command + option + p + r</strong></p>
<ul>
<li>重置 NVRAM 或 PRAM。
<blockquote>
<p>根据apple官方文档(<a href="https://support.apple.com/zh-cn/HT204063">重置 Mac 上的 NVRAM 或 PRAM</a>)
NVRAM（非易失性随机访问存储器）是一小部分内存，Mac 使用这些内存来储存某些设置并对其进行快速访问。PRAM（参数 RAM）储存着类似的信息，且 NVRAM 和 PRAM 的重置步骤相同。
可储存在 NVRAM 中的设置包括音量、显示屏分辨率、启动磁盘选择、时区，以及最近的内核崩溃信息。储存在 NVRAM 中的设置取决于您的 Mac 以及与这台 Mac 搭配使用的设备。
如果您遇到与这些设置或其他设置有关的问题，那么重置 NVRAM 可能会有帮助。例如，如果 Mac 并非从“启动磁盘”偏好设置中选定的磁盘启动，或者在 Mac 启动前短暂地显示了一个问号图标，则可能需要重置 NVRAM。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>shift</strong></p>
<ul>
<li>以 <strong>安全模式</strong> 启动。它会执行某些检查并防止某些软件自动载入或打开。根据apple官方文档。
<blockquote>
<p>根据apple官方文档(<a href="https://support.apple.com/zh-cn/HT201262">使用安全模式查明 Mac 的相关问题
</a>)</p>
</blockquote>
<blockquote>
<p>以安全模式启动 Mac 会完成以下操作：</p>
<ul>
<li>验证启动磁盘，并根据需要尝试修复目录问题</li>
<li>仅载入所需的内核扩展</li>
<li>防止启动项和登录项自动打开</li>
<li>停用用户安装的字体</li>
<li>删除字体缓存、内核缓存和其他系统缓存文件</li>
<li>如果您的 Mac 出现问题，但这个问题在您以安全模式启动时消失，您或许能够查明问题原因。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>正常情况，一般使用 <strong>command + r</strong> 命令就可以满足需求了。</p>
<h4 id="12-格式化硬盘">1.2 格式化硬盘</h4>
<p>进入 <strong>安全模式</strong> 之后，选择 <strong>macOS实用工具</strong> -&gt;  <strong>磁盘工具</strong> ，然后在菜单栏中选择 <strong>查看</strong> -&gt; <strong>显示所有设备</strong>，选中硬盘进行格式化，需要自定义磁盘名称，磁盘格式和方案选择默认就可以了。</p>
<h4 id="13-在线重装系统">1.3 在线重装系统</h4>
<p>格式化硬盘之后，返回 <strong>macOS实用工具</strong> ，选择 <strong>重新安装mac OS</strong> ，点击继续，选择安装磁盘，点击继续。在线安装根据网络状态，需要的时间也不等。在安装过程中，请保持电源连接，不要合上上盖，以便安装完成。</p>
<h2 id="2系统配置">2.系统配置</h2>
<p>系统重装完成之后，重新激活系统。可以选择从 <strong>Time Mechine</strong> 中还原系统，不过有个小问题。如果你使用icloud，备份的系统中 <strong>icloud drive</strong> 文件如果不是最新，那么会很麻烦。<strong>icloud drive</strong> 坑还是比较多的。在这里，我选择暂不传输，当做一台新电脑来折腾。
进入系统之后，首先将mac自带的软件用一个文件夹装起来，毕竟原生的APP很多都不是很顺手。接下来，真正的工作就要开始了。
首先我们来对mac进行一些配置。</p>
<h4 id="21-允许运行第三方应用">2.1 允许运行第三方应用。</h4>
<pre><code>malideMacBook-Pro:Downloads mali$ sudo spctl --master-disable
Password:
malideMacBook-Pro:Downloads mali$ 
</code></pre>
<h4 id="22-显示隐藏文件">2.2 显示隐藏文件</h4>
<pre><code>defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder //显示隐藏文件
defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder //不显示隐藏文件
</code></pre>
<p>在 <strong>macOS Sierra</strong> 系统之后，直接使用 <strong>command + shift + .</strong> 就可以快速切换。</p>
<h4 id="23-生成公钥私钥">2.3 生成公钥私钥</h4>
<p>在Mac上有多种方式来生成公钥和私钥。</p>
<ol>
<li>openssl。macOS系统自带openssl，</li>
<li>ssh_keygen</li>
</ol>
<pre><code> ✘ mali@malideMacBook-Pro  ~  ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/mali/.ssh/id_rsa):
Created directory '/Users/mali/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /Users/mali/.ssh/id_rsa.
Your public key has been saved in /Users/mali/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:qNJ/iRrfK66Qd0hG1f1JvkeyB4IfiuwP9lYqN7Vz1vw mali@malideMacBook-Pro.local
The key's randomart image is:
+---[RSA 2048]----+
|      .. .       |
|     .  . . .    |
|    .    . + .   |
|   .   .. o * .  |
|    o...So o *   |
|   = oo . + o o  |
|  + *.+. = . =   |
|   + *=+B o o o  |
|    o++B=o +   .E|
+----[SHA256]-----+
 mali@malideMacBook-Pro  ~ 
</code></pre>
<h2 id="3-装机必备">3 装机必备</h2>
<p>配置完成之后，就要开始安装常用的软件了。</p>
<h4 id="31-输入法">3.1 输入法</h4>
<p>首先就是输入法，apple自带的输入法我是用不惯的，还是搜狗拼音顺手，多平台同步词库。</p>
<h4 id="32-1password">3.2 1password</h4>
<p>在当前时代，每个人都有巨量的账号。那么，账号密码的管理就是个大问题。1password就是一款密码管理的保险箱。
除了支付宝、微信、以及各大银行的手机银行，我所有的账号密码都是由1password来管理。如果不安装1password，那我根本就不记得我的密码。平时需要做的，只是根据1password的提示更新密码等就可以了。
另外，1password支持多平台，iphone，mac，windows，chrome插件等。据说windows下体验很差，不过我很少用，所以无所谓啦。
当然，也存在一些问题，比如说mac客户端和chrome插件的重叠。mac客户端可以日常使用，覆盖整个电脑。不过，在有些网站，密码输入框是禁止复制的，chrome插件则可以强行写入。二者缺一不可，所以只能多次输入主密码来解密了。</p>
<h4 id="33-chrome-lantern">3.3 chrome + lantern</h4>
<p>chrome是浏览器，lantern是一款VPN。</p>
<p>safari很好用，但是毕竟只能在apple生态内用，有着太多局限性。作为一个开发人员，虽然不是前端，当然也是使用chrome啦。对于我这种懒人来说，最重要的就是多端同步，在任何一台机器上登陆账号，都可以同步所有配置、拓展。当然，chrome也有坑，就是官方下载chrome需要翻墙，登陆google账号同步个人数据时也需要翻墙。我是在本地保存了chrome的安装包和democross的安装文件，安装之后就可以使用了。</p>
<p><a href="https://github.com/getlantern/lantern">lantern</a>，我一般是直接上GitHub下载。不过，在现在的大环境下，lantern也不是很好用了，经常性的连不上。我目前是用的免费版，每个月500M流量，同步chrome数据够用了。</p>
<p>当然，作为程序员，翻墙是基本需求了，lantern这每个月500M肯定是不够用的。所以我另外用了一个工具， <strong>DemoCross</strong> ，是chrome中的一个extention，巨稳定，也很便宜，9块一个月；当然，也有缺陷，只能在chrome中使用。基本满足我的需求了。</p>
<h4 id="34-homebrew">3.4 homebrew</h4>
<p>homebrew是一款 Mac OS 系统下的第三方软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多使用的功能。homebrew会将软件包安装到独立目录，并将其文件symlink（软连接）到 /usr/local/Cellar 路径下。</p>
<h5 id="341-安装homebrew">3.4.1 安装homebrew</h5>
<pre><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<h5 id="342-卸载homebrew">3.4.2 卸载homebrew</h5>
<pre><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;  
</code></pre>
<h5 id="343-homebrew常用命令及使用">3.4.3 homebrew常用命令，及使用。</h5>
<pre><code>brew help                  //帮助
brew update                //更新homebrew软件，把所有的Formula目录更新，并且会对本机已经安装并有更新的软件标明。
brew upgrade               //更新homebrew软件，更新所有安装的Formula。
brew upgrade [Formula]     //更新homebrew软件，更新某个Formula。
brew info [FORMULA...]     //展示某个Formula的信息。
brew search [TEXT|/REGEX/] //搜索某个Formula，支持正则表达式。
brew install [FORMULA]     //安装Formula。
brew uninstall [FORMULA]   //卸载Formula。
brew list                  //展示目前安装的软件。
</code></pre>
<h5 id="344-常用formula">3.4.4 常用Formula</h5>
<p>版本管理：git</p>
<pre><code>malideMacBook-Pro:~ mali$ brew install git
</code></pre>
<p>预览插件( <a href="https://github.com/sindresorhus/quick-look-plugins">quick-look-plugins</a> )：</p>
<blockquote>
<p>qlcolorcode    预览代码时代码高亮。
qlstephen   支持预览没有后缀的文本文件。
qlmarkdown  预览markdown文件的渲染效果。
quicklook-json    对json文件的格式化和高亮预览。
betterzip   预览压缩文件内部的内容，并支持自定义解压缩的行为；收费。
qlimagesize    图片预览时展示分辨率和大小。
webpquicklook  支持预览webP格式的图片。
qlvideo  预览更多格式的视频文件。
provisionql 可以预览.app或者.ipa文件的程序。
quicklookapk   预览安卓.apk的程序。</p>
</blockquote>
<pre><code>malideMacBook-Pro:~ mali$ brew cask install qlcolorcode qlstephen qlmarkdown quicklook-json qlimagesize webpquicklook qlvideo provisionql quicklookapk
</code></pre>
<p>下载利器：wget</p>
<pre><code>malideMacBook-Pro:~ mali$ brew install wget
</code></pre>
<h4 id="35-alfred-dropbox">3.5 Alfred + dropbox</h4>
<p><strong>Alfred</strong> 是 <strong>Mac</strong> 平台上一款著名的效率提升工具，包含功能众多。它分为免费版和付费版。一般用户使用免费版就够了。
<strong>dropbox</strong> 是境外的云盘服务，需要配备VPN才能使用。我使用它的唯一原因，只是因为Alfred配置文件同步只支持dropbox。一般保持一周更新一次的频率。</p>
<p><strong>Alfred</strong>的使用，我就不介绍了，太多文章了。这里列一些我收藏的。
<a href="https://sspai.com/post/32979">从零开始学习 Alfred：基础功能及设置</a>
<a href="https://sspai.com/post/55098">一切为了让效率更进一步，Alfred 4.0 更新详解</a>
<a href="https://sspai.com/post/34468">它已不仅仅是一款 Mac 效率启动器：Alfred 3.0 新版详解</a>
<a href="https://sspai.com/post/32680">5 款提高文件处理效率的 Alfred 扩展</a>
<a href="https://sspai.com/post/32281">4 款「本地化」的 Alfred 扩展分享</a>
<a href="https://sspai.com/post/47063">妙用 Alfred 让你最近使用的文件触手可及</a>
<a href="https://sspai.com/post/28137">OS X 效率启动器 Alfred 的最佳伴侣：Alfred Remote for iOS 上手详解</a>
<a href="https://sspai.com/post/27929">OS X 效率启动器 Alfred 的 5 个实用扩展推荐（二）</a>
<a href="https://sspai.com/post/47063">妙用 Alfred 让你最近使用的文件触手可及</a></p>
<h4 id="36-cheat-sheet">3.6 cheat sheet</h4>
<p><strong>cheat sheet</strong> 是macOS平台上一款用来查看当前页面的可用快捷键的APP，可以极大的提高效率。
使用比较简单，安装完毕之后，在 <strong>系统偏好设置</strong> -&gt; <strong>安全性与隐私</strong> -&gt; <strong>辅助功能</strong> 中添加权限，就可以正常使用啦，长按 <strong>command</strong>键即可。</p>
<h4 id="37-cleanmymac">3.7 cleanmymac</h4>
<p><strong>cleanmymac</strong> 是 macOS 平台上的电脑管家，可以进行清理缓存垃圾，卸载APP等操作。我主要把它当做一个卸载器。
收费软件，请自己考量。</p>
<h4 id="38-iterm2-oh-my-zsh">3.8 iterm2 + oh my zsh</h4>
<p>作为程序员，会有非常多的场景用到命令行。macOS系统自带的terminal有时候不是很顺手，我们可以选择另外一个更好用的命令行工具 <strong>iterm2</strong>。可以使用homebrew安装。</p>
<pre><code>malideMacBook-Pro:Downloads mali$ brew cask install iterm2
Updating Homebrew...
==&gt; Satisfying dependencies
==&gt; Downloading https://iterm2.com/downloads/stable/iTerm2-3_2_9.zip
######################################################################## 100.0%
==&gt; Verifying SHA-256 checksum for Cask 'iterm2'.
==&gt; Installing Cask iterm2
==&gt; Moving App 'iTerm.app' to '/Applications/iTerm.app'.
🍺  iterm2 was successfully installed!
malideMacBook-Pro:Downloads mali$ 
</code></pre>
<p><strong>iterm2</strong> 安装完毕之后，开始安装 <strong><a href="https://ohmyz.sh/">oh my zsh</a></strong>。</p>
<pre><code>//curl安装
malideMacBook-Pro:~ mali$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;

//wget安装
malideMacBook-Pro:~ mali$ sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;
</code></pre>
<h5 id="381-为什么用zsh">3.8.1 为什么用zsh</h5>
<p>zsh和bash都是shell的一种，不过zsh在使用中，更加便利。对我来说，仅仅是zsh的自动补全就足以让我选择用它了。向更进一步了解，可以查看下列文章。
<a href="https://www.zhihu.com/question/21418449">为什么说 zsh 是 shell 中的极品？</a>
<a href="https://www.xshell.net/shell/bash_zsh.html">Zsh和Bash，究竟有何不同 坑很深</a></p>
<h5 id="382-为什么用oh-my-zsh">3.8.2 为什么用oh my zsh</h5>
<p>zsh的配置需要花费大量的时间，而 <strong>oh my zsh</strong> 相当于是一个提供了预设个性配置的zsh，大大减少了我们配置的时间，非常推荐使用。
<a href="https://www.jianshu.com/p/d194d29e488c?open_source=weibo_search">oh-my-zsh,让你的终端从未这么爽过</a></p>
<h5 id="383-oh-my-zsh-基本使用">3.8.3 oh my zsh 基本使用</h5>
<pre><code>//查看当前使用的shell
➜  ~ echo $SHELL
/bin/zsh
➜  ~


//查看当前zsh版本
➜  ~ zsh --version
zsh 5.3 (x86_64-apple-darwin18.0)
➜  ~


//切换shell，从bash切换到zsh，需要重启iterm
➜  ~ chsh -s /bin/zsh
Changing shell for mali.
Password for mali:
➜  ~ 


//切换shell，从zsh切换到bash，需要重启iterm
➜  ~ chsh -s /bin/bash
Changing shell for mali.
Password for mali:
➜  ~


//查看当前环境安装了哪些shell
➜  ~ cat /etc/shells
# List of acceptable shells for chpass(1).
# Ftpd will not allow users to connect who are not using
# one of these shells.

/bin/bash
/bin/csh
/bin/ksh
/bin/sh
/bin/tcsh
/bin/zsh
➜  ~


//修改主题
oh my zsh 的配置文件路径是：~/.zshrc
进入配置文件，找到 ZSH_THEME 字段，修改为 ZSH_THEME=&quot;agnoster&quot;。
agnoster主题，需要Powerline字体库的支持。

//从github拉取[Powerline字体库](https://github.com/powerline/fonts)，拉取完成之后，运行install.sh文件安装。
然后设置iterm字体为 Meslo LG S DZ for Powerline 即可。
</code></pre>
<h5 id="384-iterm-基本使用">3.8.4 iterm 基本使用</h5>
<p>恢复原始配置</p>
<pre><code>~ ➤ defaults delete com.googlecode.iterm2
~ ➤
然后重启iterm即可。
</code></pre>
<h4 id="39-ssh-copy-id">3.9 ssh-copy-id</h4>
<p>SSH 是 Secure Shell 的缩写，其实就是远程 Shell 登录。只要能远程登录到某台机器的 Shell 上，大到 Mac 笔记本，小到树莓派和智能路由器，我们就可以上传或下载文件、执行脚本等等，几乎掌握了设备的控制权。一般来说，配置自己的云服务器，都需要ssh登陆。
ssh登陆时，需要制定ip地址和登录名，例如<code>ssh 192.168.1.1@root</code>，就是指登陆ip为192.168.1.1的主机的用户root。ssh协议默认端口为22，不用填写；如果设备为了安全修改了端口为1234，则必须输入，例如<code>ssh -p 1234 192.168.1.1@root</code>。接下来输入密码就可以登陆了。
不过记忆密码是一件非常麻烦的事，好在ssh支持使用RSA的公钥和私钥来验证身份。具体就是指将自己的公钥文件（ ~/.ssh/id_rsa.pub ）的内容复制到目标服务器（ ~/.ssh/authorized_keys ）文件中。这样其实也很繁琐。
<strong>ssh-copy-id</strong> 就是一款简化过程，方便我们使用的工具。
另外，可以通过ssh的配置文件配置来设置云服务器的别名，省去了记忆ip、用户名、端口号的麻烦。基本格式如下</p>
<pre><code>Host malitest
    HostName 192.168.1.1
    User root
    Port 22
    IdentityFile ~/.ssh/id_rsa
</code></pre>
<h4 id="310-irvue">3.10 irvue</h4>
<p><strong>irvue</strong> 是一款壁纸APP，基于 Unsplash ，有很多精美的图片。
其实基于 Unsplash 的壁纸APP还有好几款，不过 <strong>irvue</strong> 最让我满意的地方是，在存在多个桌面时，可以同时修改多个桌面的壁纸。
了解更多，可以参考少数派的这篇文章：<a href="https://sspai.com/post/41665">你只需要欣赏桌面，把换壁纸的事交给 Irvue 就好了</a></p>
<h4 id="311-keka">3.11 <a href="https://www.keka.io/en/">keka</a></h4>
<p>macOS 系统自身只支持zip格式，如果碰到其他格式的压缩文件，那么就需要keka来帮助你。kake是一款非常好用的压缩程序，支持各种压缩格式，支持分卷压缩，支持设置解压缩密码。</p>
<h4 id="312-iina">3.12 <a href="https://www.iina.io/">iina</a></h4>
<p>mac OS 平台上非常好用的播放器。几乎支持全部格式视频，而且小巧，轻便，界面美观。</p>
<h4 id="313-omnidisksweeper">3.13 <a href="https://www.omnigroup.com/more">OmniDiskSweeper</a></h4>
<p>一款非常轻量级的清理软件，界面简单，功能强大，而且免费！！！</p>
<h2 id="4-ios开发环境配置">4 iOS开发环境配置</h2>
<p>ios开发， 一般来说，都是使用apple提供的IDE，Xcode。另外，我习惯使用了cocoapods作为第三方库管理工具。</p>
<h4 id="41-xcode安装">4.1. Xcode安装</h4>
<p>现在一些辅助的工具安装完毕，作为一个iOS开发工程师，接下来首先要做的肯定是配置开发环境啦。
首先是Xcode。自从2015年 <code>Xcode ghost</code>事件之后，下载 <a href="https://itunes.apple.com/us/app/xcode/id497799835?mt=12">Xcode</a> 还是建议直接到mac的App Store去下载了，，非常方便，历史版本，可以直接上苹果开发者网站下载(<a href="https://developer.apple.com/download/more/?=xcode">More Downloads for Apple Developers</a>)。Xcode作为苹果官方出品的IDE，如果不是Xcode8以后禁了插件，我会更爱它。</p>
<h4 id="42-xcode模拟器安装">4.2. Xcode模拟器安装</h4>
<p>模拟器安装本来是个很简单的工作，在「Xcode -&gt; Preferences -&gt; Components」中选择想要安装的模拟器就可以了。但是，apple的服务器着实不稳定，有时候会慢的让你怀疑人生。因此，我在想会不会又更方便的安装方式呢？检索资料之后，找到了这篇文章：<a href="https://www.jianshu.com/p/fd7c40b15192">解决直接在xcode下载模拟器慢的方案</a>。感谢作者分享。
我大致介绍一下。</p>
<ol>
<li>打开「实用工具 -&gt; console」(系统控制台)。</li>
<li>进入「Xcode -&gt; Preferences -&gt; Components」，点击某个版本的模拟器进行下载。然后取消下载。在<code>console</code>中可以看到对应下载链接，该链接即这个版本的模拟器的下载路径。</li>
</ol>
<pre><code>DVTDownloadable: Download Cancelled. Downloadable: https://devimages-cdn.apple.com/downloads/xcode/simulators/com.apple.pkg.AppleTVSimulatorSDK12_1-12.1.1.1543439531.dmg.
</code></pre>
<ol start="3">
<li>把所有的模拟器都点一次，就可以获得所有的安装路径。下载就可以选择其他方式。</li>
<li>下载完成之后，进入路径<code>~/Library/Caches</code>，右击<code>com.apple.dt.Xcode</code>文件，选择<code>显示包内容</code>。再进入<code>Downloads</code>路径（没有就自己创建一个），将下载好的文件放入。</li>
<li>再次进入「Xcode -&gt; Preferences -&gt; Components」，再次点击下载。</li>
</ol>
<h4 id="43-cocoapods">4.3. <a href="https://cocoapods.org/">Cocoapods</a></h4>
<h5 id="431-cocoapods简介">4.3.1. <code>Cocoapods</code>简介</h5>
<blockquote>
<p>CocoaPods is a dependency manager for Swift and Objective-C Cocoa projects. It has over 62 thousand libraries and is used in over 3 million apps. CocoaPods can help you scale your projects elegantly.</p>
</blockquote>
<p>这是官方的一段简介。大致意思是，<code>Cocoapods</code> 是专为基于swift和Objective-C语言编写的项目提供依赖库管理的工具，拥有超过6万个第三方框架，超过300万个APP在使用它。<code>Cocoapods</code>可以让你优雅的拓展项目。
具体来说，<code>Cocoapods</code>可以帮助我们节省配置和更新第三方库的时间；另外，自己开发的组件也可以上传到<code>Cocoapods</code>，以供他人使用。</p>
<p>如果不使用<code>Cocoapods</code>，正常来说，我们使用第三方库，需要经历一下步骤：</p>
<ol>
<li>把需要使用的第三方库的源代码添加到我们的项目中。</li>
<li>配置第三方库需要的依赖（系统提供的framework，甚至是其他的第三方库）。</li>
<li>设置第三方库需要的编译条件。</li>
<li>手动管理第三方库的更新。</li>
</ol>
<p>这个过程是比较繁琐的，其中更是会出现很多奇奇怪怪的报错，处理起来非常麻烦。如果是使用<code>Cocoapods</code>，那么这些都不用管，<code>Cocoapods</code>会帮我们处理好。</p>
<p>如果想多了解<code>Cocoapods</code>，可以看下这些文章：
<a href="https://juejin.im/post/5b1cfaff6fb9a01e417b6051">我所理解的 CocoaPods</a>
<a href="http://www.code4app.com/article/cocoapods-install-usage">CocoaPods安装和使用教程</a></p>
<h5 id="432-cocoapods的安装">4.3.2. <code>Cocoapods</code>的安装</h5>
<p><code>Cocoapods</code>本质上是一个Ruby项目，由若干gems组成。因此本地需要配置Ruby环境才可以运行。在Mac系统中，是自带Ruby的。使用命令<code>Ruby -v</code>查看当前版本。</p>
<pre><code>➜  ~ Ruby -v
ruby 2.3.7p456 (2018-03-28 revision 63024) [universal.x86_64-darwin18]
➜  ~
</code></pre>
<p>如果系统版本过低，导致系统自带的ruby版本太低，是无法安装<code>cocoapods</code>的，需要升级ruby才可以。我们通常使用RVM(Ruby Verssion Manager)来管理ruby的版本。</p>
<h6 id="4321-安装rmv">4.3.2.1 安装rmv</h6>
<pre><code>➜  ~ curl -L get.rvm.io | bash -s stable
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   194  100   194    0     0     63      0  0:00:03  0:00:03 --:--:--    63
100 24168  100 24168    0     0   5638      0  0:00:04  0:00:04 --:--:-- 3034k
Downloading https://github.com/rvm/rvm/archive/1.29.8.tar.gz
Downloading https://github.com/rvm/rvm/releases/download/1.29.8/1.29.8.tar.gz.asc
Found PGP signature at: 'https://github.com/rvm/rvm/releases/download/1.29.8/1.29.8.tar.gz.asc',
but no GPG software exists to validate it, skipping.
Installing RVM to /Users/mali/.rvm/
    Adding rvm PATH line to /Users/mali/.profile /Users/mali/.mkshrc /Users/mali/.bashrc /Users/mali/.zshrc.
    Adding rvm loading line to /Users/mali/.profile /Users/mali/.bash_profile /Users/mali/.zlogin.
Installation of RVM in /Users/mali/.rvm/ is almost complete:

  * To start using RVM you need to run `source /Users/mali/.rvm/scripts/rvm`
    in all your open shell windows, in rare cases you need to reopen all shell windows.
Thanks for installing RVM 🙏
Please consider donating to our open collective to help us maintain RVM.

👉  Donate: https://opencollective.com/rvm/donate


➜  ~ source ~/.bashrc
➜  ~ source ~/.bash_profile
➜  ~
</code></pre>
<h6 id="4322-rvm的基本使用">4.3.2.2 rvm的基本使用</h6>
<p><strong>查看rvm版本</strong></p>
<pre><code>➜  ~ rvm -v
rvm 1.29.8 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io]
➜  ~
</code></pre>
<p><strong>查看可安装的ruby版本</strong></p>
<pre><code>➜  ~ rvm list known
</code></pre>
<p><strong>安装一个ruby版本，我一般安装最新的</strong></p>
<pre><code>➜  ~ rvm install 2.6.3
Searching for binary rubies, this might take some time.
No binary rubies available for: osx/10.14/x86_64/ruby-2.6.3.
Continuing with compilation. Please read 'rvm help mount' to get more information on binary rubies.
Checking requirements for osx.
Certificates bundle '/usr/local/etc/openssl@1.1/cert.pem' is already up to date.
Requirements installation successful.
Installing Ruby from source to: /Users/mali/.rvm/rubies/ruby-2.6.3, this may take a while depending on your cpu(s)...
ruby-2.6.3 - #downloading ruby-2.6.3, this may take a while depending on your connection...
** Resuming transfer from byte position 7135232
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 7201k  100 7201k    0     0  22621      0  0:05:25  0:05:25 --:--:-- 18318
ruby-2.6.3 - #extracting ruby-2.6.3 to /Users/mali/.rvm/src/ruby-2.6.3 - please wait
ruby-2.6.3 - #configuring - please wait
ruby-2.6.3 - #post-configuration - please wait
ruby-2.6.3 - #compiling - please wait
ruby-2.6.3 - #installing - please wait
ruby-2.6.3 - #making binaries executable - please wait
ruby-2.6.3 - #downloading rubygems-3.0.4
ruby-2.6.3 - #extracting rubygems-3.0.4 - please wait
ruby-2.6.3 - #removing old rubygems - please wait
$LANG was empty, setting up LANG=en_US.US-ASCII, if it fails again try setting LANG to something sane and try again.
ruby-2.6.3 - #installing rubygems-3.0.4 - please wait
ruby-2.6.3 - #gemset created /Users/mali/.rvm/gems/ruby-2.6.3@global
ruby-2.6.3 - #importing gemset /Users/mali/.rvm/gemsets/global.gems - please wait
ruby-2.6.3 - #generating global wrappers - please wait
ruby-2.6.3 - #gemset created /Users/mali/.rvm/gems/ruby-2.6.3
ruby-2.6.3 - #importing gemsetfile /Users/mali/.rvm/gemsets/default.gems evaluated to empty gem list
ruby-2.6.3 - #generating default wrappers - please wait
ruby-2.6.3 - #adjusting #shebangs for (gem irb erb ri rdoc testrb rake).
Install of ruby-2.6.3 - #complete
Ruby was built without documentation, to build it run: rvm docs generate-ri
</code></pre>
<p><strong>设置默认版本</strong></p>
<pre><code>➜  ~ rvm use 2.6.3 --default
Using /Users/mali/.rvm/gems/ruby-2.6.3
➜  ~
</code></pre>
<p><strong>更换国内源<code>https://gems.ruby-china.com/</code></strong>
由于墙的存在，因此默认的源是非常非常慢的，需要切换的国内的镜像源。</p>
<pre><code>// 移除自带源，因为国内被墙了
➜  ~ gem sources --remove https://rubygems.org/
https://rubygems.org/ removed from sources
➜  ~


//添加国内镜像源
➜  ~ gem source -a https://gems.ruby-china.com/
https://gems.ruby-china.com/ added to sources
➜  ~


// 查看是否更换成功
➜  ~ gem sources -l
*** CURRENT SOURCES ***

https://gems.ruby-china.com/
➜  ~
</code></pre>
<h6 id="4323-安装cocoapods">4.3.2.3 安装<code>cocoapods</code></h6>
<pre><code>// 安装cocoapods
➜  ~ sudo gem install cocoapods
Password:
Fetching thread_safe-0.3.6.gem
Fetching concurrent-ruby-1.1.5.gem
Fetching i18n-0.9.5.gem
Fetching activesupport-4.2.11.1.gem
Fetching fuzzy_match-2.0.4.gem
Fetching tzinfo-1.2.5.gem
Fetching nap-1.1.0.gem
Fetching cocoapods-core-1.7.2.gem
Fetching claide-1.0.2.gem
Fetching cocoapods-deintegrate-1.0.4.gem
Fetching cocoapods-downloader-1.2.2.gem
Fetching cocoapods-plugins-1.0.0.gem
Fetching cocoapods-search-1.0.0.gem
Fetching cocoapods-stats-1.1.0.gem
Fetching netrc-0.11.0.gem
Fetching cocoapods-trunk-1.3.1.gem
Fetching cocoapods-try-1.1.0.gem
Fetching molinillo-0.6.6.gem
Fetching atomos-0.1.3.gem
Fetching CFPropertyList-3.0.0.gem
Fetching colored2-3.1.2.gem
Fetching nanaimo-0.2.6.gem
Fetching xcodeproj-1.10.0.gem
Fetching escape-0.0.4.gem
Fetching fourflusher-2.3.1.gem
Fetching gh_inspector-1.1.3.gem
Fetching ruby-macho-1.4.0.gem
Fetching cocoapods-1.7.2.gem
Successfully installed thread_safe-0.3.6
Successfully installed tzinfo-1.2.5
Successfully installed concurrent-ruby-1.1.5
Successfully installed i18n-0.9.5
Successfully installed activesupport-4.2.11.1
Successfully installed nap-1.1.0
Successfully installed fuzzy_match-2.0.4
Successfully installed cocoapods-core-1.7.2
Successfully installed claide-1.0.2
Successfully installed cocoapods-deintegrate-1.0.4
Successfully installed cocoapods-downloader-1.2.2
Successfully installed cocoapods-plugins-1.0.0
Successfully installed cocoapods-search-1.0.0
Successfully installed cocoapods-stats-1.1.0
Successfully installed netrc-0.11.0
Successfully installed cocoapods-trunk-1.3.1
Successfully installed cocoapods-try-1.1.0
Successfully installed molinillo-0.6.6
Successfully installed atomos-0.1.3
Successfully installed CFPropertyList-3.0.0
Successfully installed colored2-3.1.2
Successfully installed nanaimo-0.2.6
Successfully installed xcodeproj-1.10.0
Successfully installed escape-0.0.4
Successfully installed fourflusher-2.3.1
Successfully installed gh_inspector-1.1.3
Successfully installed ruby-macho-1.4.0
Successfully installed cocoapods-1.7.2
Parsing documentation for thread_safe-0.3.6
Installing ri documentation for thread_safe-0.3.6
Parsing documentation for tzinfo-1.2.5
Installing ri documentation for tzinfo-1.2.5
Parsing documentation for concurrent-ruby-1.1.5
Installing ri documentation for concurrent-ruby-1.1.5
Parsing documentation for i18n-0.9.5
Installing ri documentation for i18n-0.9.5
Parsing documentation for activesupport-4.2.11.1
Installing ri documentation for activesupport-4.2.11.1
Parsing documentation for nap-1.1.0
Installing ri documentation for nap-1.1.0
Parsing documentation for fuzzy_match-2.0.4
Installing ri documentation for fuzzy_match-2.0.4
Parsing documentation for cocoapods-core-1.7.2
Installing ri documentation for cocoapods-core-1.7.2
Parsing documentation for claide-1.0.2
Installing ri documentation for claide-1.0.2
Parsing documentation for cocoapods-deintegrate-1.0.4
Installing ri documentation for cocoapods-deintegrate-1.0.4
Parsing documentation for cocoapods-downloader-1.2.2
Installing ri documentation for cocoapods-downloader-1.2.2
Parsing documentation for cocoapods-plugins-1.0.0
Installing ri documentation for cocoapods-plugins-1.0.0
Parsing documentation for cocoapods-search-1.0.0
Installing ri documentation for cocoapods-search-1.0.0
Parsing documentation for cocoapods-stats-1.1.0
Installing ri documentation for cocoapods-stats-1.1.0
Parsing documentation for netrc-0.11.0
Installing ri documentation for netrc-0.11.0
Parsing documentation for cocoapods-trunk-1.3.1
Installing ri documentation for cocoapods-trunk-1.3.1
Parsing documentation for cocoapods-try-1.1.0
Installing ri documentation for cocoapods-try-1.1.0
Parsing documentation for molinillo-0.6.6
Installing ri documentation for molinillo-0.6.6
Parsing documentation for atomos-0.1.3
Installing ri documentation for atomos-0.1.3
Parsing documentation for CFPropertyList-3.0.0
Installing ri documentation for CFPropertyList-3.0.0
Parsing documentation for colored2-3.1.2
Installing ri documentation for colored2-3.1.2
Parsing documentation for nanaimo-0.2.6
Installing ri documentation for nanaimo-0.2.6
Parsing documentation for xcodeproj-1.10.0
Installing ri documentation for xcodeproj-1.10.0
Parsing documentation for escape-0.0.4
Installing ri documentation for escape-0.0.4
Parsing documentation for fourflusher-2.3.1
Installing ri documentation for fourflusher-2.3.1
Parsing documentation for gh_inspector-1.1.3
Installing ri documentation for gh_inspector-1.1.3
Parsing documentation for ruby-macho-1.4.0
Installing ri documentation for ruby-macho-1.4.0
Parsing documentation for cocoapods-1.7.2
Installing ri documentation for cocoapods-1.7.2
Done installing documentation for thread_safe, tzinfo, concurrent-ruby, i18n, activesupport, nap, fuzzy_match, cocoapods-core, claide, cocoapods-deintegrate, cocoapods-downloader, cocoapods-plugins, cocoapods-search, cocoapods-stats, netrc, cocoapods-trunk, cocoapods-try, molinillo, atomos, CFPropertyList, colored2, nanaimo, xcodeproj, escape, fourflusher, gh_inspector, ruby-macho, cocoapods after 15 seconds
28 gems installed

// 安装本地库，需要等待很长时间
➜  ~ pod setup
Ignoring executable-hooks-1.6.0 because its extensions are not built. Try: gem pristine executable-hooks --version 1.6.0
Ignoring gem-wrappers-1.4.0 because its extensions are not built. Try: gem pristine gem-wrappers --version 1.4.0
Setting up CocoaPods master repo
  $ /usr/bin/git -C /Users/mali/.cocoapods/repos/master fetch origin --progress
  remote: Enumerating objects: 11494, done.
  remote: Counting objects: 100% (11494/11494), done.
  remote: Compressing objects: 100% (165/165), done.
  remote: Total 44594 (delta 11354), reused 11424 (delta 11313), pack-reused 33100
  Receiving objects: 100% (44594/44594), 5.01 MiB | 36.00 KiB/s, done.
  Resolving deltas: 100% (30150/30150), completed with 4479 local objects.
  From https://github.com/CocoaPods/Specs
     c68db42388d..082ed90868f  master     -&gt; origin/master
   + a1c937ec508...02443419999 indexes    -&gt; origin/indexes  (forced update)
   * [new branch]              netlify    -&gt; origin/netlify
  $ /usr/bin/git -C /Users/mali/.cocoapods/repos/master rev-parse --abbrev-ref HEAD
  master
  $ /usr/bin/git -C /Users/mali/.cocoapods/repos/master reset --hard origin/master
  Checking out files: 100% (4657/4657), done.
  HEAD is now at 082ed90868f [Add] WrapModel 1.0.8
Setup completed
➜  ~
</code></pre>
<h6 id="4324-cocoapods常用命令">4.3.2.4 <code>cocoapods</code>常用命令</h6>
<pre><code>// 当前使用 pod 版本
pod –version
// 更新到最新稳定版本
sudo gem install cocoapods
// 安装指定版本
sudo gem install cocoapods -v [版本号]
// 移除 CocoaPods，如果你安装多个，会列出一个 list 让你选择删除那个。如果只安装一个，也会给你提示，问你是否确定删除。
sudo gem uninstall cocopods
// 移除指定版本
sudo gem uninstall cocopods -v [版本号]
// 初始化项目`cocoapods`
pod init
// Podfile 中添加组件
pod ‘’
// 安装组件
pod install
// 安装组件的详细过程
pod install –verbose
// 更新某一组件
pod update [组件名]
// 更新本地依赖
pod repo update
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信支付]]></title>
        <id>https://codermali.github.io/malideLibrary.github.io//post/wei-xin-zhi-fu</id>
        <link href="https://codermali.github.io/malideLibrary.github.io//post/wei-xin-zhi-fu">
        </link>
        <updated>2019-06-21T09:21:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="微信支付">微信支付</h3>
<h5 id="接入微信支付首先需要注册微信商户号">接入微信支付首先需要注册微信商户号。</h5>
<ol>
<li>打开 <a href="https://pay.weixin.qq.com/index.php/core/home/login?return_url=%2F">微信支付</a> 首页，选择「成为商家，选择「注册微信支付商户号」，然后绑定管理员微信。</li>
<li>完成以上操作后，进入申请流程。分为三个步骤：创建申请单，填写商户信息，确认提交。
<ul>
<li>创建申请单中，需要输入管理员的各种信息；</li>
<li>填写商户信息过程中，可以选择四个类型：个体工商户，企业，党政、机关及事业单位，其他组织。我选择的是企业，需要三证合一的营业执照，法人身份证，对公账户，经营信息以及结算规则。
<ul>
<li>在这个过程中，我碰到一个问题。在填写经营信息时，我选择的经营场景是APP，微信提示需要提供APP首页截图、尾页截图、应用内截图、支付页截图各1张。但是目前我们的APP是并没有开发完成。因此，只能使用其他方式先注册，在APP开发完成之后，再进行更换。</li>
</ul>
</li>
<li>确认提交，主要是对提交资料的一个确认，并提交审核。</li>
</ul>
</li>
<li>资料提交成功之后，需要进行账户验证。有两种方式：
<ol>
<li>使用法人微信认证。</li>
<li>使用公账汇款。
<ul>
<li>使用公账汇款，会有延迟。</li>
</ul>
</li>
</ol>
</li>
<li>账户验证通过之后，需要等待微信审核结果。我们公司公账是招商银行账户，48小时内有结果。<a href="http://kf.qq.com/faq/161223BfIRVz161223zA3ieY.html">点击查看具体</a></li>
</ol>
<h3 id="支付宝支付">支付宝支付</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://codermali.github.io/malideLibrary.github.io//post/hello-gridea</id>
        <link href="https://codermali.github.io/malideLibrary.github.io//post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>𝖶𝗂𝗇𝖽𝗈𝗐𝗌</strong> 或 <strong>𝖬𝖺𝖼𝖮𝖲</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>