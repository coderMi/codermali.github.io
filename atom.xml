<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://codermali.github.io/malideLibrary.github.io/</id>
    <title>malide Library</title>
    <updated>2019-07-18T15:11:29.816Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://codermali.github.io/malideLibrary.github.io/"/>
    <link rel="self" href="https://codermali.github.io/malideLibrary.github.io//atom.xml"/>
    <subtitle>人生如逆旅，我亦是行人。</subtitle>
    <logo>https://codermali.github.io/malideLibrary.github.io//images/avatar.png</logo>
    <icon>https://codermali.github.io/malideLibrary.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, malide Library</rights>
    <entry>
        <title type="html"><![CDATA[阿里云centOS6.8 设置开机启动]]></title>
        <id>https://codermali.github.io/malideLibrary.github.io//post/a-li-yun-centos68-she-zhi-kai-ji-qi-dong</id>
        <link href="https://codermali.github.io/malideLibrary.github.io//post/a-li-yun-centos68-she-zhi-kai-ji-qi-dong">
        </link>
        <updated>2019-07-18T10:25:27.000Z</updated>
        <content type="html"><![CDATA[<h4 id="基础知识">基础知识</h4>
<pre><code>chkconfig是管理系统服务(service)的命令行工具。所谓系统服务(service)，就是随系统启动而启动，随系统关闭而关闭的程序。
chkconfig命令主要用来更新（启动或停止）和查询系统服务的运行级信息。谨记chkconfig不是立即自动禁止或激活一个服务，它只是简单的改变了符号连接。
chkconfig提供5个功能：	
</code></pre>
<ol>
<li>设置service启动信息</li>
</ol>
<pre><code>//on、off、reset用于改变service的启动信息。 
//on表示开启，off表示关闭，reset表示重置。 
//默认情况下，on和off开关只对运行级2，3，4，5有效，reset可以对所有运行级有效。
chkconfig name on/off/reset
</code></pre>
<ol start="2">
<li>设置service运行级别</li>
</ol>
<pre><code>//指定运行级为2,3,4,5 
//等级0表示：表示关机 
//等级1表示：单用户模式 
//等级2表示：无网络连接的多用户命令行模式 
//等级3表示：有网络连接的多用户命令行模式 
//等级4表示：不可用 
//等级5表示：带图形界面的多用户模式 
//等级6表示：重新启动
chkconfig --level 2345 name on
</code></pre>
<ol start="3">
<li>添加service</li>
</ol>
<pre><code>chkconfig --add name
</code></pre>
<ol start="4">
<li>移除service</li>
</ol>
<pre><code>chkconfig --del name
</code></pre>
<ol start="5">
<li>列出service的启动信息</li>
</ol>
<pre><code>chkconfig --list [name]
</code></pre>
<h2 id="设置mysql开启自启动">设置mysql开启自启动</h2>
<ol>
<li>将mysql安装目录下/support目录下的mysql.server文件复制到/etc/init.d/目录下，并改名为mysqld</li>
</ol>
<pre><code>cp /software/mysql/mysql-5.7.18-linux-glibc2.5-x86_64/support-files/mysql.server /etc/init.d/mysqld
</code></pre>
<ol start="2">
<li>设置mysqld文件的执行权限</li>
</ol>
<pre><code>chmod a+x /etc/init.d/mysqld
</code></pre>
<ol start="3">
<li>此时，我们可以通过该文件启动和停止mysql服务</li>
</ol>
<pre><code>[root@iZwz9cngn5wj3bafyrd539Z /]# /etc/init.d/mysqld start
Starting MySQL.                                            [  OK  ]
[root@iZwz9cngn5wj3bafyrd539Z /]# /etc/init.d/mysqld stop
Shutting down MySQL..                                      [  OK  ]
[root@iZwz9cngn5wj3bafyrd539Z /]#
</code></pre>
<ol start="4">
<li>将mysqld服务添加到chkconfig管理列表,然后就可以通过service对mysql进行启动和停止了</li>
</ol>
<pre><code>[root@iZwz9cngn5wj3bafyrd539Z /]# chkconfig --add mysqld

[root@iZwz9cngn5wj3bafyrd539Z /]# service mysqld start
Starting MySQL.                                            [  OK  ]
[root@iZwz9cngn5wj3bafyrd539Z /]# service mysqld stop
Shutting down MySQL..                                      [  OK  ]
[root@iZwz9cngn5wj3bafyrd539Z /]# 
</code></pre>
<ol start="5">
<li>设置终端模式开机启动</li>
</ol>
<pre><code>[root@iZwz9cngn5wj3bafyrd539Z /]# chkconfig mysqld on
</code></pre>
<h2 id="设置tomcat自动启动">设置tomcat自动启动</h2>
<ol>
<li>编辑startup.sh文件</li>
</ol>
<pre><code>//到tomcat/bin目录下，在#!/bin/sh这一行下面，也就是第二行，添加如下内容
#chkconfig: 2345 80 90    
#description:tomcat auto start    
#processname: tomcat
</code></pre>
<ol start="2">
<li>编辑catalina.sh文件</li>
</ol>
<pre><code>//搜索export位置,在后面添加
export CATALINA_BASE=/usr/local/tomcat
export CATALINA_HOME=/usr/local/tomcat
export CATALINA_TMPDIR=/usr/local/tomcat

//在#!/bin/sh这一行下面，也就是第二行,添加Java路径
export JAVA_HOME=/software/java/jdk1.8.0_171
export JER_HOME=/software/java/jdk1.8.0_171/jre
</code></pre>
<ol start="3">
<li>链接starup.sh文件到/etc/init.d/目录下,并添加操作权限</li>
</ol>
<pre><code>ln -s /software/tomcat/apache-tomcat-8.5.32/bin/startup.sh /etc/init.d/tomcat8

chmod a+x /etc/init.d/tomcat8
</code></pre>
<ol start="4">
<li>添加tomcat8文件到开机启动服务列表</li>
</ol>
<pre><code>chkconfig --add tomcat8

chkconfig tomcat8 on 

chkconfig --list
</code></pre>
<h2 id="设置nginx开机自启动">设置nginx开机自启动</h2>
<ol>
<li>编辑自启动脚本文件，并保存到/etc/init.d/nginx</li>
</ol>
<pre><code>//nginx官方链接：https://www.nginx.com/resources/wiki/start/topics/examples/redhatnginxinit/

//需要修改的地方
nginx=”/usr/sbin/nginx” 修改成nginx执行程序的路径。
NGINX_CONF_FILE=”/etc/nginx/nginx.conf” 修改成配置文件的路径。

#!/bin/sh
#
# nginx - this script starts and stops the nginx daemon
#
# chkconfig:   - 85 15
# description:  NGINX is an HTTP(S) server, HTTP(S) reverse \
#               proxy and IMAP/POP3 proxy server
# processname: nginx
# config:      /etc/nginx/nginx.conf
# config:      /etc/sysconfig/nginx
# pidfile:     /var/run/nginx.pid

# Source function library.
. /etc/rc.d/init.d/functions

# Source networking configuration.
. /etc/sysconfig/network

# Check that networking is up.
[ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;&amp; exit 0

nginx=&quot;/usr/sbin/nginx&quot;
prog=$(basename $nginx)

NGINX_CONF_FILE=&quot;/etc/nginx/nginx.conf&quot;

[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginx

lockfile=/var/lock/subsys/nginx

make_dirs() {
   # make required directories
   user=`$nginx -V 2&gt;&amp;1 | grep &quot;configure arguments:.*--user=&quot; | sed 's/[^*]*--user=\([^ ]*\).*/\1/g' -`
   if [ -n &quot;$user&quot; ]; then
      if [ -z &quot;`grep $user /etc/passwd`&quot; ]; then
         useradd -M -s /bin/nologin $user
      fi
      options=`$nginx -V 2&gt;&amp;1 | grep 'configure arguments:'`
      for opt in $options; do
          if [ `echo $opt | grep '.*-temp-path'` ]; then
              value=`echo $opt | cut -d &quot;=&quot; -f 2`
              if [ ! -d &quot;$value&quot; ]; then
                  # echo &quot;creating&quot; $value
                  mkdir -p $value &amp;&amp; chown -R $user $value
              fi
          fi
       done
    fi
}

start() {
    [ -x $nginx ] || exit 5
    [ -f $NGINX_CONF_FILE ] || exit 6
    make_dirs
    echo -n $&quot;Starting $prog: &quot;
    daemon $nginx -c $NGINX_CONF_FILE
    retval=$?
    echo
    [ $retval -eq 0 ] &amp;&amp; touch $lockfile
    return $retval
}

stop() {
    echo -n $&quot;Stopping $prog: &quot;
    killproc $prog -QUIT
    retval=$?
    echo
    [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile
    return $retval
}

restart() {
    configtest || return $?
    stop
    sleep 1
    start
}

reload() {
    configtest || return $?
    echo -n $&quot;Reloading $prog: &quot;
    killproc $nginx -HUP
    RETVAL=$?
    echo
}

force_reload() {
    restart
}

configtest() {
  $nginx -t -c $NGINX_CONF_FILE
}

rh_status() {
    status $prog
}

rh_status_q() {
    rh_status &gt;/dev/null 2&gt;&amp;1
}

case &quot;$1&quot; in
    start)
        rh_status_q &amp;&amp; exit 0
        $1
        ;;
    stop)
        rh_status_q || exit 0
        $1
        ;;
    restart|configtest)
        $1
        ;;
    reload)
        rh_status_q || exit 7
        $1
        ;;
    force-reload)
        force_reload
        ;;
    status)
        rh_status
        ;;
    condrestart|try-restart)
        rh_status_q || exit 0
            ;;
    *)
        echo $&quot;Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}&quot;
        exit 2
esac
</code></pre>
<ol start="2">
<li>设置文件的执行权限</li>
</ol>
<pre><code>chmod a+x /etc/init.d/nginx
</code></pre>
<ol start="3">
<li>添加nginx到chkconfig</li>
</ol>
<pre><code>[root@iZwz9cngn5wj3bafyrd539Z ~]# chkconfig --add nginx
[root@iZwz9cngn5wj3bafyrd539Z ~]# chkconfig --list
[root@iZwz9cngn5wj3bafyrd539Z ~]# chkconfig --level 2345 nginx on
</code></pre>
<h2 id="设置redis开机自启动">设置redis开机自启动</h2>
<ol>
<li>复制redis安装目录下的/redis/utils/redis_init_script到/etc/init.d/redis</li>
</ol>
<pre><code>cp /software/redis/redis-3.2.12/utils/redis_init_script /etc/init.d/redis
</code></pre>
<ol start="2">
<li>编辑redis文件</li>
</ol>
<pre><code>//1.在#！/bin/sh下一行，添加chkconfig配置
//redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10
# chkconfig: 2345 10 90  
# description: Start and Stop redis

//2.修改redis安装的相关目录
REDISPORT=6379
EXEC=/software/redis/redis-3.2.12/src/redis-server
CLIEXEC=/software/redis/redis-3.2.12/src/redis-cli

PIDFILE=/var/run/redis_${REDISPORT}.pid
CONF=&quot;/software/redis/redis-3.2.12/redis.conf&quot;
</code></pre>
<ol start="3">
<li>设置文件的执行权限</li>
</ol>
<pre><code>chmod a+x /etc/init.d/redis
</code></pre>
<ol start="4">
<li>添加nginx到chkconfig</li>
</ol>
<pre><code>[root@iZwz9cngn5wj3bafyrd539Z ~]# chkconfig --add redis
[root@iZwz9cngn5wj3bafyrd539Z ~]# chkconfig --list
[root@iZwz9cngn5wj3bafyrd539Z ~]# chkconfig redis on
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[应用转让]]></title>
        <id>https://codermali.github.io/malideLibrary.github.io//post/ying-yong-zhuan-rang</id>
        <link href="https://codermali.github.io/malideLibrary.github.io//post/ying-yong-zhuan-rang">
        </link>
        <updated>2019-07-18T10:19:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>APP开发完成之后，上线是通过本公司的账号上线。现在需要转让。具体流程如下。</p>
<h4 id="apple-developer">Apple Developer</h4>
<p>在APP Store上线的APP，想要转让，可以根据苹果官方文档：<a href="https://help.apple.com/app-store-connect/#/deved688524f">App 转让概述</a>。<br>
首先是注册开发apple账号。目前，注册账号必须开启两步认证，也就是说必有要用一台apple的设备（mac，ipad，iphone，ipod等）来登陆账号。<br>
开发者账号注册需要公司提供有效的官网地址。</p>
<h4 id="应用宝开发资质已认证app转让完成">应用宝（开发资质已认证，APP转让完成）</h4>
<p>经过和客服的沟通，客服提示步骤如下：</p>
<ul>
<li>开发者账号登陆 → 管理中心 → 点击需要转让的应用 → 基础能力 → 工单系统 → 应用宝商务类 → 移动应用转让申请 → 填单提交。（工单不需要上传截图）</li>
<li>应用转入的开发者账号必须保证已经在开放平台上通过审核，应用转入和转出的开发者账号均为QQ号码，请勿使用其他账号，否则不予受理。</li>
</ul>
<p>填写对应资料，提交审核之后，就是等待了。审核时间是2个工作日。</p>
<p>等待了一个工作日左右，审核通过，APP已经转移到新的账号，不过应用宝内的iOS端APP需要重新配置（我刚才找了下，貌似iOS端的APP是不能转移的）。</p>
<h4 id="百度移动开放平台开发资质已认证app认领完成">百度移动开放平台（开发资质已认证，app认领完成）</h4>
<p>经过和客服沟通，客服说，需要走认领流程。“软件版权资质”可以上传“软著”或者“保证函”；“证明文件”可以提交营业执照。<br>
认领成功之后，需要重新填写应用资料，打包提交。</p>
<p>碰到一个问题，应用认领成功，也重新上线，但是在百度移动应用市场，APP的开发者信息还是之前账号的。联系客服，居然让改包名重新上线。。。我真是醉了。客服说帮忙同步数据，24小时候之后看结果，不知道真假。<br>
决定还是发邮件咨询，<code>ext_app_support@baidu.com</code> ，等待结果。</p>
<p>邮件客服建议修改包名再次提交。。。百度人都特么有毒。。。还是说我误会了，安卓的包名其实没那么重要。</p>
<p>在线客服帮我同步数据的操作有效，app开发资质已变更。</p>
<h4 id="华为开发者联盟开发资质已认证">华为开发者联盟（开发资质已认证）</h4>
<p>在华为开发者联盟找了一圈，没有找到相关信息。已经提交工单，等待中。<br>
客服提供了一份文档：<a href="https://developer.huawei.com/consumer/cn/devservice/doc/50112">应用转移操作指南</a>。<br>
按照要求，发邮件到<code>developer@huawei.com</code>。邮件格式：</p>
<ul>
<li>1）邮件标题：【应用转移】+应用名称。</li>
<li>2）邮件正文注明：转出帐号、转入帐号、应用名称、APPID及您的联系方式。</li>
<li>3）邮件附件包含：应用转移申请表，应用转移自检表</li>
</ul>
<h4 id="小米开放平台开发资质已认证app认领完成">小米开放平台（开发资质已认证，APP认领完成）</h4>
<p>在官网上只找到<a href="https://dev.mi.com/console/doc/detail?pId=882">应用认领操作说明</a>，但是我希望的是转让。因此发邮件去到客服咨询，等待中。<br>
等了一天没有回应。算了，直接认领。流程比较简单，新注册账号，并完成开发资质认证，新建一个同名同包名的应用，就会进入认领流程。下载没有签名的APK空包，交给Android开发，重新签名，上传，瞬间就认领过来了。</p>
<h4 id="oppo开放平台开发资质已认证">oppo开放平台（开发资质已认证，）</h4>
<p>和在线客服沟通之后，客户给了一份材料：<a href="https://open.oppomobile.com/wiki/doc#id=10182">应用认领流程</a>。只需要应用宝，华为，小米转移之后，提供后台截图就可以了。</p>
<h4 id="vivo开放平台开发资质已认证">vivo开放平台（开发资质已认证，）</h4>
<p>根据<a href="https://dev.vivo.com.cn/documentCenter/doc/54">应用认领</a>，貌似和oppo开放平台差不多的流程。不过，值得一提是，vivo的小v客服，提示前面还有9个人，排队。然后下午排了三个多小时，还要继续排队，服气了，放弃。</p>
<h4 id="mob开放平台开发资质已认证app转让完成">mob开放平台（开发资质已认证，APP转让完成）</h4>
<p>在mob平台申请账号，在身份认证之后，会需要输入QQ号。然后，官方客服会添加好友。所以转移应用的事，我直接就和客服联系了。客服推送了另一个专门负责这一块的客服给我。<br>
经过沟通，转移应用之后APPKey和APPSecret不会变动，不影响APP正常使用。<br>
转移流程如下，首先把需要转移的APP的名称和APPKey发送给客服，然后向Mob官方邮箱（support@mob.com）发送一封邮件,内容包含：</p>
<ol>
<li>申请应用转移的原因；</li>
<li>申请转移的应用名称及应用的APPKEY；</li>
<li>旧账号（如有请提供）以及申请转移到哪个新的账号；</li>
<li>公司名称及营业执照（旧账号）；</li>
<li>申请人的姓名、身份证号码（需手持身份证拍照，身份证上的信息需清晰可见），以及联系方式。</li>
</ol>
<p>之后，会有客服联系转移前账号联系人，进行确认。多说一句，妹子声音真好听，哈哈。确认完毕，在一两天之内就会转移成功了。</p>
<h4 id="微信开放平台">微信开放平台</h4>
<p>在网上没有找到APP迁移的相关资料。所幸找到微信开放平台的客服邮箱（weixin-open@qq.com），经过几个来回的沟通，可以确定微信开放平台是提供APP迁移这项服务的。迁移之后，迁移应用的openid、appSecret不变，unionid会变。</p>
<p>迁移需要开发者向客服邮箱发送指定格式的邮件进行申请，要求如下：<br>
以“【帐号应用迁移需求】迁出open帐号xxxx，迁入open帐号xxxx”为邮件主题，邮件发送至weixin-open@qq.com，确认迁出帐号和迁入帐号都为已认证状态，并提交以下材料：</p>
<ol>
<li>需求背景</li>
<li>具体迁出、迁入open帐号信息</li>
<li>迁出应用信息（应用名称、应用appid）</li>
<li>加盖原开发者和新开发者主体公章的转移申请函（模板见附件）；</li>
<li>原开发者和新开发者的主体资质材料（营业执照、组织机构代码证）；</li>
<li>申请迁移APP的应用市场截图：iOS截带有bundleID的界面，android截带有包名、签名的界面；</li>
<li>申请迁移APP的软件著作权证扫描件等可以证明应用归属证明。</li>
</ol>
<p>首先是注册微信开放平台账号。注册时需要公司官网。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS State Restoration]]></title>
        <id>https://codermali.github.io/malideLibrary.github.io//post/ios-state-restoration</id>
        <link href="https://codermali.github.io/malideLibrary.github.io//post/ios-state-restoration">
        </link>
        <updated>2019-06-24T17:35:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>最近项目中碰到了一个问题：由于编辑器占用内存过多，导致APP进入后台之后，很快就会被杀掉。这个时候，如果用户正在使用编辑器，那么编辑器里面的内容就会丢失了。针对这个问题，我想到了几个解决方案。</p>
<ol>
<li>通过后台播放无声音乐，请求定位等方式让APP在后台长时间留存。不过跟群友交流过之后，发现很大的可能不会过审，放弃。（后来又有群友说后台播放无声音乐是可以通过审核的，没有证实。）</li>
<li>添加草稿功能。实时本地（云端）保存编辑器中的内容，重新进入编辑器之后加载缓存。这样就又有几个问题。首先，是否需要本地缓存APP被杀掉时的页面，在APP重新启动时，根据缓存的路径，进入页面。这样的话就需要对页面的路径进行配置、判断，想想就很麻烦；第二，是项目中有多个编辑器，编辑器中内容可能非常多，使用轻量级的plist、NSUserDefaults、NSKeyedAchiever等可能不是很合适，使用数据库又觉得没必要。</li>
</ol>
<p>在这个时候，偶然发现 Apple 针对本身的伪后台系统，提供了一套API，让我们来恢复在后台被杀掉的APP的状态。那就是<code>UIStateRestoration</code>。</p>
<h3 id="app-state-restoration简介"><code>APP State Restoration</code>简介</h3>
<p>由于iOS系统的设计，APP在后台停留时间过长，就很有可能被杀掉。然而，为了更好的体验，我们是希望APP可以一直停留在后台的。为了弥补这一点，在iOS 6.0版本之后，为我们一共了一套API，让我们可以在APP在后台被杀掉之后，重新启动APP时，可以恢复到APP被杀掉之前的状态。</p>
<h3 id="api介绍部分">API介绍（部分。。。）</h3>
<pre><code>@protocol UIViewControllerRestoration  //必须实现。
//这个方法使用来创建或者找到相关的viewController。如果返回为nil，那么就不会恢复该viewController以及它的子视图。
+ (nullable UIViewController *) viewControllerWithRestorationIdentifierPath:(NSArray&lt;NSString *&gt; *)identifierComponents coder:(NSCoder *)coder;
@end

//这个协议是用来恢复UITableVie和UICollectionView的数据
@protocol UIDataSourceModelAssociation
- (nullable NSString *) modelIdentifierForElementAtIndexPath:(NSIndexPath *)idx inView:(UIView *)view;
- (nullable NSIndexPath *) indexPathForElementWithModelIdentifier:(NSString *)identifier inView:(UIView *)view;
@end

#pragma mark -- State Restoration object protocols and methods --

@protocol UIObjectRestoration;

@protocol UIStateRestoring &lt;NSObject&gt;
@optional

@property (nonatomic, readonly, nullable) id&lt;UIStateRestoring&gt; restorationParent;

@property (nonatomic, readonly, nullable) Class&lt;UIObjectRestoration&gt; objectRestorationClass;

//这两个方式是用来保存和恢复当前页面中需要保存的数据的。
- (void) encodeRestorableStateWithCoder:(NSCoder *)coder;
- (void) decodeRestorableStateWithCoder:(NSCoder *)coder;

//在所有的数据都恢复之后执行。
- (void) applicationFinishedRestoringState;
@end

@protocol UIObjectRestoration
+ (nullable id&lt;UIStateRestoring&gt;) objectWithRestorationIdentifierPath:(NSArray&lt;NSString *&gt; *)identifierComponents coder:(NSCoder *)coder;
@end
</code></pre>
<p>###API使用<br>
在实际的使用中，分为两种情况。</p>
<ol>
<li><code>以UINavigationController</code>为根控制器。因为<code>UINavigationController</code>会自动记录子视图的层级，因此非常容易实现，这里不多说。Apple官方的demo也是基于<code>UINavigationController</code>的。</li>
<li>以<code>UITableViewController</code>为根控制器。<code>UITableViewController</code>不会记录子视图的层级，因此需要对自己来定义。</li>
</ol>
<p>在这里，我们基于<code>UITableViewController</code>和<code>UINavigationController</code>为构架的普通APP为例子实现APP状态的恢复。</p>
<h5 id="一-首先需要实现appdelegate的两个方法">一、首先需要实现APPDelegate的两个方法。</h5>
<pre><code>/**
该方法在APP进入后台，或者在前台被用户主动杀掉时执行。（如果被系统杀掉，或者用户在后台杀掉，则不会执行）。返回`YES`，通知APPDelegate，在APP进入后台时，需要保存
State。
*/
- (BOOL)application:(UIApplication *)application shouldSaveApplicationState:(NSCoder *)coder {
    return YES;
}

/**
如果APP是异常关闭（后台被杀等），那么在下一次启动时，会执行这个方法。返回`YES`，通知APPDelegate，保存的状态需要被恢复。执行顺序为：
[AppDelegate application:willFinishLaunchingWithOptions:]
[AppDelegate application:shouldRestoreApplicationState:]
[AppDelegate application:didFinishLaunchingWithOptions:]
*/
- (BOOL)application:(UIApplication *)application shouldRestoreApplicationState:(NSCoder *)coder {
    return YES;
}
</code></pre>
<h5 id="二-需要在appdelegate-applicationdidfinishlaunchingwithoptions方法中进行处理并实现appdelegate-applicationwillfinishlaunchingwithoptions方法">二、需要在<code>[AppDelegate application:didFinishLaunchingWithOptions:]</code>方法中进行处理，并实现<code>[AppDelegate application:willFinishLaunchingWithOptions:]</code>方法。</h5>
<pre><code>- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    
    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
    
    return YES;
}


- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {

    if (!self.window.rootViewController) {
        TabBarController *tabBarC = [[TabBarController alloc] init];
        self.window.rootViewController = tabBarC;
    }
    [self.window makeKeyAndVisible];
    
    return YES;
}
</code></pre>
<h5 id="三-根控制器uitableviewcontroller遵守并实现协议">三、根控制器<code>UITableViewController</code>遵守并实现协议。</h5>
<pre><code>#import &quot;TabBarController.h&quot;

@interface TabBarController ()&lt;UIViewControllerRestoration&gt;

@end

@implementation TabBarController

+ (UIViewController *)viewControllerWithRestorationIdentifierPath:(NSArray&lt;NSString *&gt; *)identifierComponents coder:(NSCoder *)coder {

    TabBarController *tabBarC = [[TabBarController alloc] init];
    [[UIApplication sharedApplication] delegate].window.rootViewController = tabBarC;
    
    return tabBarC;
}

@end
</code></pre>
<h5 id="四-uinavigationcontroller准守并实现协议">四、<code>UINavigationController</code>准守并实现协议。</h5>
<pre><code>#import &quot;NavigationController.h&quot;
#import &quot;TabBarController.h&quot;
#import &quot;HomeController.h&quot;
#import &quot;DynamicController.h&quot;
#import &quot;MineController.h&quot;

@interface NavigationController ()&lt;UIViewControllerRestoration&gt;

@end

@implementation NavigationController

- (instancetype)initWithRootViewController:(UIViewController *)rootViewController {
    if (self = [super initWithRootViewController:rootViewController]) {
        
        UIViewController *viewController = self.viewControllers.firstObject;
        if ([viewController isKindOfClass:[HomeController class]]) {
            self.restorationIdentifier = @&quot;home&quot;;
        }
        if ([viewController isKindOfClass:[DynamicController class]]) {
            self.restorationIdentifier = @&quot;dynamic&quot;;
        }
        if ([viewController isKindOfClass:[MineController class]]) {
            self.restorationIdentifier = @&quot;mine&quot;;
        }
        
        self.restorationClass = [self class];
    }
    return self;
}


+ (UIViewController *)viewControllerWithRestorationIdentifierPath:(NSArray&lt;NSString *&gt; *)identifierComponents coder:(NSCoder *)coder {

    TabBarController *tabBarC = (TabBarController *)[[UIApplication sharedApplication] delegate].window.rootViewController;
    
    NSString *identifier = identifierComponents.lastObject;
    NavigationController *navigationC = nil;
    if ([identifier isEqualToString:@&quot;home&quot;]) {
        navigationC = (NavigationController *)tabBarC.viewControllers[0];
    }
    else if ([identifier isEqualToString:@&quot;dynamic&quot;]) {
        navigationC = (NavigationController *)tabBarC.viewControllers[1];
    }
    else if ([identifier isEqualToString:@&quot;mine&quot;]) {
        navigationC = (NavigationController *)tabBarC.viewControllers[2];
    }
    
    return navigationC;
}

@end
</code></pre>
<h5 id="五-uinavigationcontroller的根控制器遵守并实现协议">五、<code>UINavigationController</code>的根控制器遵守并实现协议</h5>
<pre><code>#import &quot;HomeController.h&quot;

@interface HomeController ()&lt;UIViewControllerRestoration&gt;

@end

@implementation HomeController

- (instancetype)init {
    if (self = [super init]) {
        self.restorationIdentifier = NSStringFromClass([self class]);
        self.restorationClass = [self class];
    }
    return self;
}


+ (UIViewController *)viewControllerWithRestorationIdentifierPath:(NSArray&lt;NSString *&gt; *)identifierComponents coder:(NSCoder *)coder {
//    UITabBarController *rootViewController = (TabBarController *)[UIApplication sharedApplication].delegate.window.rootViewController;

    TabBarController *tabBarC = (TabBarController *)[[UIApplication sharedApplication] delegate].window.rootViewController;
    NavigationController *navigationC = (NavigationController *)tabBarC.viewControllers[0];
    HomeController *homeC = [navigationC.viewControllers firstObject];
    
    return homeC;
}


- (void)encodeRestorableStateWithCoder:(NSCoder *)coder {
    [super encodeRestorableStateWithCoder:coder];
    
}


- (void)decodeRestorableStateWithCoder:(NSCoder *)coder {
    [super decodeRestorableStateWithCoder:coder];
    
}

@end
</code></pre>
<h5 id="六-要恢复的视图遵守并实现协议">六、要恢复的视图遵守并实现协议</h5>
<pre><code>#import &quot;HomeDetailController.h&quot;

@interface HomeDetailController ()&lt;UIViewControllerRestoration&gt;

@end

@implementation HomeDetailController

- (instancetype)init {
    if (self = [super init]) {
        self.restorationIdentifier = NSStringFromClass([self class]);
        self.restorationClass = [self class];
    }
    return self;
}


+ (UIViewController *)viewControllerWithRestorationIdentifierPath:(NSArray&lt;NSString *&gt; *)identifierComponents coder:(NSCoder *)coder {
    return [[self alloc] init];
}


- (void)encodeRestorableStateWithCoder:(NSCoder *)coder {
    [super encodeRestorableStateWithCoder:coder];
}


- (void)decodeRestorableStateWithCoder:(NSCoder *)coder {
    [super decodeRestorableStateWithCoder:coder];
}


- (void)applicationFinishedRestoringState {
}
</code></pre>
<p>到这里，基本上就实现了APP状态的恢复功能。不过还有一些小问题。如果是自定义了<code>UINavigationController</code>，在<code>[UINavigationController pushViewController:animated:]</code>方法中『自定义导航条返回按钮』，设置『跳转时隐藏底部导航条（hidesBottomBarWhenPushed）』等，那么在恢复APP状态之后，这些都会失效。因为在恢复状态的过程中，并没有调用<code>[UINavigationController pushViewController:animated:]</code>方法。目前我没有太好的解决办法，只能在自定义的基类中代码实现再次实现『自定义导航条返回按钮』等功能。</p>
<p>赶时间的碰到看到这里就可以停止了。接下来主要是根据我的理解，解析一下恢复状态的过程。有兴趣的朋友可以看一下。</p>
<h4 id="参考文章">参考文章</h4>
<p><a href="https://www.jianshu.com/p/0b11bcffa115">如何实现UITabbarController 的State Restoration?</a></p>
<p><a href="https://www.jianshu.com/p/66940242d4e9">另类的&quot;APP常驻&quot;——UIStateRestoration</a></p>
<p><a href="https://www.jianshu.com/p/7f2fe9361f07">iOS的App实现状态恢复</a></p>
<p><a href="https://www.jianshu.com/p/b1bbf01f2596">保存和恢复App的状态</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac 系统重装指南]]></title>
        <id>https://codermali.github.io/malideLibrary.github.io//post/mac-xi-tong-chong-zhuang-zhi-nan</id>
        <link href="https://codermali.github.io/malideLibrary.github.io//post/mac-xi-tong-chong-zhuang-zhi-nan">
        </link>
        <updated>2019-06-24T11:02:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>最近公司入职了一个新的iOS开发，趁着这个时机，把旧电脑安排给了新员工，然后换了一台新 MacBook Pro。这样，就涉及到资料的备份和转移，还好以往我把公司资料直接保存在icloud，这就省了很多时间。但是除了资料，mac上的开发环境、配置等等就需要重新配置了。</p>
<p>回想一下，重装电脑很多次了，每次都要查资料，重新配置。一方面是太麻烦了，另一方面，这样也会把自己很多配置文件丢失，比如：Xcode中的snips，ssh方面的常用的服务器，git和svn中的配置等等。因此希望将这次系统重装流程记录下来，并建立一个备份的资料库，作为自己的积累。</p>
<p>本文基于 <strong>macOS 10.14.5</strong> 。</p>
<h3 id="1-重装系统">1、重装系统</h3>
<h4 id="11-macos-恢复系统">1.1、macOS 恢复系统</h4>
<p>mac开机时有根据不同的命令，可以分别进入不同的模式。(参考<a href="https://support.apple.com/zh-cn/HT201255">Mac 的启动组合键</a>)。</p>
<ul>
<li>
<p><strong>command + r</strong></p>
</li>
<li>
<p>进入内置的 <strong>macOS 恢复系统</strong>。只有在系统恢复盘还存在的时候使用。安装您的 Mac 上装有的最新 macOS。</p>
</li>
<li>
<p><strong>command + option + r</strong></p>
</li>
<li>
<p>进入内置的 <strong>macOS 恢复系统</strong>。即使系统恢复盘报废，也可以恢复系统。升级到与您的 Mac 兼容的最新 macOS。</p>
</li>
<li>
<p><strong>command + shift + option + r</strong></p>
</li>
<li>
<p>进入内置的 <strong>macOS 恢复系统</strong>。即使系统恢复盘报废，也可以恢复系统。安装 Mac 随附的 macOS 或与它最接近且仍在提供的版本。</p>
</li>
<li>
<p><strong>option</strong></p>
</li>
<li>
<p>进入 <strong>启动管理器</strong>。如果该电脑安装了多个系统，那么就可以在这里选择启动盘。</p>
</li>
<li>
<p><strong>command + option + p + r</strong></p>
<ul>
<li>重置 NVRAM 或 PRAM。
<blockquote>
<p>根据apple官方文档(<a href="https://support.apple.com/zh-cn/HT204063">重置 Mac 上的 NVRAM 或 PRAM</a>)<br>
NVRAM（非易失性随机访问存储器）是一小部分内存，Mac 使用这些内存来储存某些设置并对其进行快速访问。PRAM（参数 RAM）储存着类似的信息，且 NVRAM 和 PRAM 的重置步骤相同。<br>
可储存在 NVRAM 中的设置包括音量、显示屏分辨率、启动磁盘选择、时区，以及最近的内核崩溃信息。储存在 NVRAM 中的设置取决于您的 Mac 以及与这台 Mac 搭配使用的设备。<br>
如果您遇到与这些设置或其他设置有关的问题，那么重置 NVRAM 可能会有帮助。例如，如果 Mac 并非从“启动磁盘”偏好设置中选定的磁盘启动，或者在 Mac 启动前短暂地显示了一个问号图标，则可能需要重置 NVRAM。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>shift</strong></p>
<ul>
<li>以 <strong>安全模式</strong> 启动。它会执行某些检查并防止某些软件自动载入或打开。根据apple官方文档。
<blockquote>
<p>根据apple官方文档(<a href="https://support.apple.com/zh-cn/HT201262">使用安全模式查明 Mac 的相关问题<br>
</a>)</p>
</blockquote>
<blockquote>
<p>以安全模式启动 Mac 会完成以下操作：</p>
<ul>
<li>验证启动磁盘，并根据需要尝试修复目录问题</li>
<li>仅载入所需的内核扩展</li>
<li>防止启动项和登录项自动打开</li>
<li>停用用户安装的字体</li>
<li>删除字体缓存、内核缓存和其他系统缓存文件</li>
<li>如果您的 Mac 出现问题，但这个问题在您以安全模式启动时消失，您或许能够查明问题原因。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>正常情况，一般使用 <strong>command + r</strong> 命令就可以满足需求了。</p>
<h4 id="12-格式化硬盘">1.2、格式化硬盘</h4>
<p>进入 <strong>安全模式</strong> 之后，选择 <strong>macOS实用工具</strong> -&gt;  <strong>磁盘工具</strong> ，然后在菜单栏中选择 <strong>查看</strong> -&gt; <strong>显示所有设备</strong>，选中硬盘进行格式化，需要自定义磁盘名称，磁盘格式和方案选择默认就可以了。</p>
<h4 id="13-在线重装系统">1.3、在线重装系统</h4>
<p>格式化硬盘之后，返回 <strong>macOS实用工具</strong> ，选择 <strong>重新安装mac OS</strong> ，点击继续，选择安装磁盘，点击继续。在线安装根据网络状态，需要的时间也不等。在安装过程中，请保持电源连接，不要合上上盖，以便安装完成。</p>
<h3 id="2-系统配置">2、系统配置</h3>
<p>系统重装完成之后，重新激活系统。可以选择从 <strong>Time Mechine</strong> 中还原系统，不过有个小问题。如果你使用icloud，备份的系统中 <strong>icloud drive</strong> 文件如果不是最新，那么会很麻烦。<strong>icloud drive</strong> 坑还是比较多的。在这里，我选择暂不传输，当做一台新电脑来折腾。<br>
进入系统之后，首先将 <code>mac</code> 自带的软件用一个文件夹装起来，毕竟原生的APP很多都不是很顺手。接下来，真正的工作就要开始了。<br>
首先我们来对mac进行一些配置。</p>
<h4 id="21-允许运行第三方应用">2.1、允许运行第三方应用。</h4>
<p>允许 <code>mac</code> 安装第三方的应用， 避免出现安装的应用不能运行，或者提示“已损坏”。</p>
<pre><code>malideMacBook-Pro:Downloads mali$ sudo spctl --master-disable
Password:
malideMacBook-Pro:Downloads mali$ 
</code></pre>
<h4 id="22-显示隐藏文件">2.2、显示隐藏文件</h4>
<p>在 <strong>macOS Sierra</strong> 系统之后，直接使用 <strong>command + shift + .</strong> 就可以快速切换。</p>
<pre><code>defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder //显示隐藏文件
defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder //不显示隐藏文件
</code></pre>
<h4 id="23-生成公钥私钥">2.3、生成公钥私钥</h4>
<p>在Mac上有多种方式来生成公钥和私钥。</p>
<ol>
<li>openssl。macOS系统自带openssl。</li>
<li>ssh_keygen</li>
</ol>
<pre><code> ✘ mali@malideMacBook-Pro  ~  ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/mali/.ssh/id_rsa):
Created directory '/Users/mali/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /Users/mali/.ssh/id_rsa.
Your public key has been saved in /Users/mali/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:qNJ/iRrfK66Qd0hG1f1JvkeyB4IfiuwP9lYqN7Vz1vw mali@malideMacBook-Pro.local
The key's randomart image is:
+---[RSA 2048]----+
|      .. .       |
|     .  . . .    |
|    .    . + .   |
|   .   .. o * .  |
|    o...So o *   |
|   = oo . + o o  |
|  + *.+. = . =   |
|   + *=+B o o o  |
|    o++B=o +   .E|
+----[SHA256]-----+
 mali@malideMacBook-Pro  ~ 
</code></pre>
<h3 id="3-装机必备">3、装机必备</h3>
<p>配置完成之后，就要开始安装必备的软件了。</p>
<h4 id="31-输入法">3.1、输入法</h4>
<p>输入法，是一个多平台都需要使用的工具，比如手机，mac，pc等等。</p>
<p>苹果自带的输入法，性能当然是最好的。不过有一个问题，就是只能在apple生态内用，另外联想功能不是很好。所以我还是习惯性的使用 <strong>sougou输入法</strong> ，可以多平台同步，之前的输入习惯都可以同步过来。</p>
<h4 id="32-1password">3.2、<a href="https://1password.com/">1password</a></h4>
<p>在当前时代，每个人都有巨量的账号。那么，账号密码的管理就是个大问题。如果多平台都使用同一个密码，很容易就会被撞库导致数据泄露；但是针对不同平台设置不同的密码，是一件耗时耗力的事情。</p>
<p><strong>1password</strong> 就是一款密码管理的保险箱，只需要记住一个主密码，用来登陆 <strong>1password</strong> ，其他所有的账号密码都由 <strong>1password</strong> 来保存，需要使用时，直接调取使用就可以。同时，<strong>1password</strong> 还会检查密码的泄露情况和其他安全问题，及时提示用户修改。</p>
<p>目前，除了支付宝、微信、以及各大银行的手机银行，我所有的账号密码都是由<strong>1password</strong> 来管理。如果不安装<strong>1password</strong> ，那我根本就不记得我的密码。平时需要做的，只是根据<strong>1password</strong> 的提示更新密码等就可以了。<br>
另外，<strong>1password</strong> 支持多平台，<strong>iphone</strong> ，<strong>mac</strong> ，<strong>windows</strong> ，<strong>chrome</strong> 插件等，多平台实时同步。据说windows下体验很差，不过我很少用，所以无所谓啦。</p>
<h4 id="33-chrome-lantern">3.3、 <a href="https://www.google.cn/chrome/">chrome</a>  + <a href="https://github.com/getlantern/lantern">lantern</a></h4>
<p><strong>chrome</strong> 是浏览器，<strong>lantern</strong> 是一款VPN。</p>
<p><strong>macOS</strong> 自带的 <strong>safari</strong> 很好用，但是只能在apple生态内用，有着太多局限性。作为一个开发人员，虽然不是前端，当然也是使用 <strong>chrome</strong> 啦。对于我这种懒人来说，最重要的就是多端同步，在任何一台机器上登陆账号，都可以同步所有配置、拓展。当然， <strong>chrome</strong> 也有坑，就是官方下载 <strong>chrome</strong> 需要翻墙，登陆google账号同步个人数据时也需要翻墙。我是在本地保存了 <strong>chrome</strong> 的安装包和 <strong>democross</strong> 的安装文件，安装之后就可以使用了。</p>
<p><strong>lantern</strong> ，我一般是直接上 **GitHub **下载。不过，在现在的大环境下，lantern也不是很好用了，经常性的连不上。我目前是用的免费版，每个月500M流量，同步 <strong>chrome</strong> 数据够用了。</p>
<p>当然，作为程序员，翻墙是基本需求了，<strong>lantern</strong> 这每个月500M肯定是不够用的。所以我另外用了一个工具， <strong>DemoCross</strong> ，是 <strong>chrome</strong> 中的一个 **extention ** ，巨稳定，也很便宜，9块一个月；当然，也有缺陷，只能在 <strong>chrome</strong> 中使用。基本满足我的需求了。</p>
<h4 id="34-alfred-dropbox">3.4、<a href="https://www.alfredapp.com/">Alfred</a> + <a href="https://www.dropbox.com/">dropbox</a></h4>
<p><strong>Alfred</strong> 是 <strong>Mac</strong> 平台上一款著名的效率提升工具，包含功能众多。它分为免费版和付费版。一般用户使用免费版就够了。<br>
<strong>dropbox</strong> 是境外的云盘服务，需要配备VPN才能使用。我使用它的唯一原因，只是因为Alfred配置文件同步只支持dropbox。一般保持一周更新一次的频率。</p>
<p><strong>Alfred</strong>的使用，我就不介绍了，太多文章了。这里列一些我收藏的。</p>
<p><a href="https://sspai.com/post/32979">从零开始学习 Alfred：基础功能及设置</a></p>
<p><a href="https://sspai.com/post/55098">一切为了让效率更进一步，Alfred 4.0 更新详解</a></p>
<p><a href="https://sspai.com/post/34468">它已不仅仅是一款 Mac 效率启动器：Alfred 3.0 新版详解</a></p>
<p><a href="https://sspai.com/post/32680">5 款提高文件处理效率的 Alfred 扩展</a></p>
<p><a href="https://sspai.com/post/32281">4 款「本地化」的 Alfred 扩展分享</a></p>
<p><a href="https://sspai.com/post/47063">妙用 Alfred 让你最近使用的文件触手可及</a></p>
<p><a href="https://sspai.com/post/28137">OS X 效率启动器 Alfred 的最佳伴侣：Alfred Remote for iOS 上手详解</a></p>
<p><a href="https://sspai.com/post/27854">OS X 效率启动器 Alfred 的 5 个实用扩展推荐（一）</a></p>
<p><a href="https://sspai.com/post/27929">OS X 效率启动器 Alfred 的 5 个实用扩展推荐（二）</a></p>
<p><a href="https://sspai.com/post/47063">妙用 Alfred 让你最近使用的文件触手可及</a></p>
<h4 id="35-keka">3.5、<a href="https://www.keka.io/en/">keka</a></h4>
<p><strong>macOS</strong> 系统自身只支持zip格式的解压和压缩。</p>
<p>但是，在工作和生活中，我们总是会碰到其他的压缩格式，7Z、gz、tar等等，这个时候就需要第三方的软件支持。<strong>kake</strong> 就是一款非常好用的压缩程序，支持各种压缩格式，支持分卷压缩，支持设置解压缩密码。</p>
<h4 id="36-macos-空间清理">3.6、macOS 空间清理</h4>
<p>清理垃圾，一般是指清除系统和各APP运行时产生的缓存。实际上，如果硬盘空间够用，是不用清理的。但是，mac硬盘空间太贵了，那么提高硬盘使用率就很有必要了。</p>
<ul>
<li>
<p><a href="https://www.omnigroup.com/more">OmniDiskSweeper</a>  一款非常轻量级的清理软件，界面简单，功能强大，而且免费！！！</p>
</li>
<li>
<p><a href="https://cleanmymac.com/">CleanMyMac</a> 一款非常优秀的垃圾清理软件，集成了很多系统提供的 Automator ，收费，并且价值不菲。</p>
</li>
</ul>
<h4 id="37-ntfs-for-mac">3.7、NTFS for mac</h4>
<p>在操作系统中，<strong>windows</strong> 才是主流，<strong>macOS</strong> 毕竟算是小众。因此，在日常工作生活中，经常会有在 <strong>macOS</strong> 和 <strong>windows</strong> 系统之间进行数据传输的需求。然而，由于 <strong>NTFS</strong> 属于微软的私有格式，已经被注册为知识产权产品，因此 <strong>macOS</strong> 系统将 <strong>NTFS</strong> 格式的写入功能屏蔽了。目前 <strong>macOS</strong> 系统只支持 <strong>NTFS</strong> 的读取，不支持写入。为了解决这个问题，这个时候我们就需要提供 <strong>NTFS for mac</strong> 服务的软件来帮助我们实现对外置硬盘或者U盘中数据的读写等操作。</p>
<p>目前主流的软件有：<a href="https://www.paragon-software.com/home/ntfs-mac/">paragon NTFS</a> 和 <a href="https://www.tuxera.com/products/tuxera-ntfs-for-mac/">tuxera NTFS</a>。</p>
<p>具体比较可以看这篇文章：<a href="https://www.lizhi.io/blog/92878401">Tuxera vs Paragon: Mac 上的 NTFS 磁盘读写工具怎么选？</a></p>
<h4 id="38-office-wps">3.8、office || wps</h4>
<p>日常办公软件，当然也是必须的。据说现在 <strong>wps</strong> 的使用体验已经很好了，不过我已经用惯了 <strong>office</strong> ，因此就不考虑 <strong>wps</strong> 了。</p>
<p>在使用 <strong>office</strong> 的过程中，我碰到过一个问题，在 <strong>office</strong> 的偏好设置里设置语言是无效的，只能跟随系统语言。查资料发现，是可以调整的。以word 为例，在命令行中输入 <code>defaults write com.microsoft.Word AppleLanguages '(&quot;zh-tw&quot;)'</code> ，然后重启即可。具体可以查看这篇文章： <a href="https://www.jianshu.com/p/96f930d2ffca">Office for Mac 语言设置问题</a> 。</p>
<h3 id="4-其他常用软件">4、其他常用软件</h3>
<h4 id="41-印象笔记">4.1、印象笔记</h4>
<p>我把印象笔记作为一款收集软件，意思是说，只做收藏，不做编辑。</p>
<h4 id="42-pocket">4.2、pocket</h4>
<p><strong>pocket</strong>是一款主流的稍后读APP，全平台支持，能够随时随地的将内容保存到APP内。</p>
<h4 id="43-百度网盘">4.3、百度网盘</h4>
<p>其实是真不想安装，不过很多资源分享都是通过百度网盘，而不安装的话，根本不能下载，百度这招真的很恶心人。</p>
<h4 id="44-teamviewer">4.4、teamviewer</h4>
<p>远程必备。</p>
<h4 id="45-macsfancontrol">4.5、macsfancontrol</h4>
<p>可以自由控制mac的风扇。</p>
<h4 id="46-截屏与录屏">4.6、截屏与录屏</h4>
<p><code>macOS</code>系统本身已经提供了截屏和录屏功能。 进入 <strong>System Preference</strong> -&gt;  <strong>keyboard</strong> -&gt; <strong>Shortcuts</strong> -&gt; <strong>Screenshots</strong> 查看。</p>
<ul>
<li><code>⌘ + ⇧ + 3</code> 截取全屏，并保存在桌面。</li>
<li><code>⌃ + ⌘ + ⇧ + 3</code> 截取全屏，并保存到粘贴板。</li>
<li><code>⌘ + ⇧ + 4</code> 截取选择区域，并保存在桌面。</li>
<li><code>⌃ + ⌘ + ⇧ + 4</code> 截取选择区域，并保存到粘贴板。</li>
<li><code>⌘ + ⇧ + 4</code> 进入截屏、录屏选择界面。</li>
</ul>
<p>系统的功能已经非常强大，能够满足基本的需求。更多了解可以查看以下文章。</p>
<p><a href="https://support.apple.com/zh-cn/HT201361">如何在 Mac 上拍摄屏幕快照</a></p>
<p><a href="https://www.jianshu.com/p/1acc00625d03">Mac OS小技巧：如何用好自带的截图工具</a></p>
<p>另外，QQ和微信也内置了截图服务，登陆之后，使用快捷键 <code>⌘ + ⌃ + A</code> 。效果类似于一款腾讯出品的软件：<a href="https://apps.apple.com/cn/app/%E6%88%AA%E5%9B%BE-jietu-%E5%BF%AB%E9%80%9F%E6%A0%87%E6%B3%A8-%E4%BE%BF%E6%8D%B7%E5%88%86%E4%BA%AB%E7%9A%84%E6%88%AA%E5%B1%8F%E5%B7%A5%E5%85%B7/id1059334054?mt=12">截图</a> 。</p>
<p>如果对这些都不满意，可以选择另一款腾讯出品的截图软件： <a href="https://snip.qq.com/">snip</a> 。</p>
<p>至于录屏，可以使用 <a href="https://www.cockos.com/licecap/">LICEcap</a> ，这是一款简介医用的动画屏幕录制软件，可以捕捉屏幕的区域并保存为gif动画或lcf格式。</p>
<h4 id="47-远程桌面-远程文件传输">4.7、远程桌面、远程文件传输</h4>
<p>和云服务器的文件传输，一般使用ftp或者sftp。</p>
<ul>
<li>文件传输协议（File Transfer Protocol，FTP）是用于在<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C">网络</a>上进行文件传输的一套标准协议，它工作在 OSI 模型的第七层， TCP 模型的第四层， 即应用层， 使用 TCP 传输而不是 UDP， 客户在和服务器建立连接前要经过一个“三次握手”的过程， 保证客户与服务器之间的连接是可靠的， 而且是面向连接， 为数据传输提供可靠保证。 FTP允许用户以文件操作的方式（如文件的增、删、改、查、传送等）与另一主机相互通信。然而， 用户并不真正登录到自己想要存取的计算机上面而成为完全用户， 可用FTP程序访问远程资源， 实现用户往返传输文件、目录管理以及访问电子邮件等等， 即使双方计算机可能配有不同的操作系统和文件存储方式。</li>
<li>sftp是SSH File Transfer Protocol的缩写，安全<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AE">文件传送协议</a>。可以为传输文件提供一种安全的网络的加密方法。sftp 与 ftp 有着几乎一样的语法和功能。SFTP 为 <a href="https://baike.baidu.com/item/SSH/10407">SSH</a>的其中一部分，是一种传输档案至 Blogger 伺服器的安全方式。其实在SSH软件包中，已经包含了一个叫作SFTP(Secure File Transfer Protocol)的安全文件信息传输子系统，SFTP本身没有单独的<a href="https://baike.baidu.com/item/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/966835">守护进程</a>，它必须使用sshd守护进程（<a href="https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3">端口</a>号默认是22）来完成相应的连接和答复操作，所以从某种意义上来说，SFTP并不像一个<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>程序，而更像是一个客户端程序。SFTP同样是使用加密传输认证信息和传输的数据，所以，使用SFTP是非常安全的。但是，由于这种传输方式使用了加密/<a href="https://baike.baidu.com/item/%E8%A7%A3%E5%AF%86%E6%8A%80%E6%9C%AF/10808578">解密技术</a>，所以<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E6%95%88%E7%8E%87/7856651">传输效率</a>比普通的<a href="https://baike.baidu.com/item/FTP/13839">FTP</a>要低得多。</li>
</ul>
<p>目前阿里云ECS centOS系统，内置了sftp服务，可以直接通过sftp方式传输文件。如果需要使用ftp，需要自行在云服务器上安装ftp服务了。</p>
<p>在macOS 可以使用命令行来实现数据的传输。具体可以查看以下文章。</p>
<p><a href="https://blog.csdn.net/chuangxin/article/details/80839322">Mac如何使用SSH远程连接linux及使用SCP、SFTP和Filezilla进行文件上传、下载</a></p>
<p>当然，我更习惯使用GUI的客户端。这里有两个推荐。远程桌面使用 <a href="https://apps.apple.com/cn/app/parallels-client/id600925318?l=en&amp;mt=12">Parallels Client</a> 。文件传输，本来是购买的yummy ftp pro。不过在某个版本更新之后，我的购买就失效了，无奈之中。替换成 <a href="https://apps.apple.com/cn/app/forklift-file-manager-and-ftp-sftp-webdav-amazon-s3-client/id412448059?mt=12">ForkLift</a> ，除了每次都需要输入账号密码，其他的都挺好用的。</p>
<h4 id="48-cheat-sheet">4.8、cheat sheet</h4>
<p><strong>cheat sheet</strong> 是macOS平台上一款用来查看当前页面的可用快捷键的APP，可以极大的提高效率。<br>
使用比较简单，安装完毕之后，在 <strong>系统偏好设置</strong> -&gt; <strong>安全性与隐私</strong> -&gt; <strong>辅助功能</strong> 中添加权限，就可以正常使用啦，长按 <strong>command</strong>键即可。</p>
<h4 id="49-irvue">4.9、<a href="https://apps.apple.com/cn/app/irvue/id1039633667?mt=12">irvue</a></h4>
<p><strong>irvue</strong> 是一款壁纸APP，基于 Unsplash ，有很多精美的图片。</p>
<p>其实基于 Unsplash 的壁纸APP还有好几款，不过 <strong>irvue</strong> 最让我满意的地方是，在存在多个桌面时，可以同时修改多个桌面的壁纸。</p>
<p>了解更多，可以参考少数派的这篇文章：<a href="https://sspai.com/post/41665">你只需要欣赏桌面，把换壁纸的事交给 Irvue 就好了</a> 。</p>
<h4 id="410-iina">4.10、<a href="https://www.iina.io/">iina</a></h4>
<p>mac OS 平台上非常好用的播放器。几乎支持全部格式视频，而且小巧，轻便，界面美观。</p>
<h4 id="411-istat-menus">4.11、<a href="https://bjango.com/mac/istatmenus/">iStat Menus</a></h4>
<p><strong>iStat Menus</strong> 是一款非常强大的系统监控软件。通过它，可以最直观的了解几乎所有硬件的运行状态，它主要运行在系统状态栏。<br>
具体使用可以参考以下文章：<br>
<a href="https://sspai.com/post/41089">不仅系统监控要做得更出色，iStat Menu 6 还能让你在状态栏看天气了</a><br>
<a href="https://sspai.com/post/26754">OS X 是了不起的操作系统：全能系统监测工具 iStat Menus 5 体验详解</a></p>
<h3 id="5-ios开发环境配置">5、iOS开发环境配置</h3>
<p>ios开发， 一般来说，都是使用apple提供的IDE： <strong>Xcode</strong> 。另外，我习惯了使用 <strong>cocoapods</strong> 作为第三方库管理工具。</p>
<h4 id="51-xcode安装">5.1、Xcode安装</h4>
<p>现在一些辅助的工具安装完毕，作为一个iOS开发工程师，接下来首先要做的肯定是配置开发环境啦。<br>
首先是Xcode。自从2015年 <code>Xcode ghost</code>事件之后，下载 <a href="https://itunes.apple.com/us/app/xcode/id497799835?mt=12">Xcode</a> 还是建议直接到mac的App Store去下载了，，非常方便，历史版本，可以直接上苹果开发者网站下载(<a href="https://developer.apple.com/download/more/?=xcode">More Downloads for Apple Developers</a>)。Xcode作为苹果官方出品的IDE，如果不是Xcode8以后禁了插件，我会更爱它。</p>
<h4 id="52-xcode模拟器安装">5.2、Xcode模拟器安装</h4>
<p>模拟器安装本来是个很简单的工作，在「Xcode -&gt; Preferences -&gt; Components」中选择想要安装的模拟器就可以了。但是，apple的服务器着实不稳定，有时候会慢的让你怀疑人生。因此，我在想会不会又更方便的安装方式呢？检索资料之后，找到了这篇文章：<a href="https://www.jianshu.com/p/fd7c40b15192">解决直接在xcode下载模拟器慢的方案</a>。感谢作者分享。<br>
我大致介绍一下。</p>
<ol>
<li>打开「实用工具 -&gt; console」(系统控制台)。</li>
<li>进入「Xcode -&gt; Preferences -&gt; Components」，点击某个版本的模拟器进行下载。然后取消下载。在<code>console</code>中可以看到对应下载链接，该链接即这个版本的模拟器的下载路径。</li>
</ol>
<pre><code>DVTDownloadable: Download Cancelled. Downloadable: https://devimages-cdn.apple.com/downloads/xcode/simulators/com.apple.pkg.AppleTVSimulatorSDK12_1-12.1.1.1543439531.dmg.
</code></pre>
<ol start="3">
<li>把所有的模拟器都点一次，就可以获得所有的安装路径。下载就可以选择其他方式。</li>
<li>下载完成之后，进入路径<code>~/Library/Caches</code>，右击<code>com.apple.dt.Xcode</code>文件，选择<code>显示包内容</code>。再进入<code>Downloads</code>路径（没有就自己创建一个），将下载好的文件放入。</li>
<li>再次进入「Xcode -&gt; Preferences -&gt; Components」，再次点击下载。</li>
</ol>
<h4 id="53-cocoapods">5.3、<a href="https://cocoapods.org/">Cocoapods</a></h4>
<h5 id="531-cocoapods简介">5.3.1、<code>Cocoapods</code>简介</h5>
<blockquote>
<p>CocoaPods is a dependency manager for Swift and Objective-C Cocoa projects. It has over 62 thousand libraries and is used in over 3 million apps. CocoaPods can help you scale your projects elegantly.</p>
</blockquote>
<p>这是官方的一段简介。大致意思是，<code>Cocoapods</code> 是专为基于swift和Objective-C语言编写的项目提供依赖库管理的工具，拥有超过6万个第三方框架，超过300万个APP在使用它。<code>Cocoapods</code>可以让你优雅的拓展项目。<br>
具体来说，<code>Cocoapods</code>可以帮助我们节省配置和更新第三方库的时间；另外，自己开发的组件也可以上传到<code>Cocoapods</code>，以供他人使用。</p>
<p>如果不使用<code>Cocoapods</code>，正常来说，我们使用第三方库，需要经历一下步骤：</p>
<ol>
<li>把需要使用的第三方库的源代码添加到我们的项目中。</li>
<li>配置第三方库需要的依赖（系统提供的framework，甚至是其他的第三方库）。</li>
<li>设置第三方库需要的编译条件。</li>
<li>手动管理第三方库的更新。</li>
</ol>
<p>这个过程是比较繁琐的，其中更是会出现很多奇奇怪怪的报错，处理起来非常麻烦。如果是使用<code>Cocoapods</code>，那么这些都不用管，<code>Cocoapods</code>会帮我们处理好。</p>
<p>如果想多了解<code>Cocoapods</code>，可以看下这些文章：<br>
<a href="https://juejin.im/post/5b1cfaff6fb9a01e417b6051">我所理解的 CocoaPods</a><br>
<a href="http://www.code4app.com/article/cocoapods-install-usage">CocoaPods安装和使用教程</a></p>
<h5 id="532-cocoapods的安装">5.3.2、<code>Cocoapods</code>的安装</h5>
<p><code>Cocoapods</code>本质上是一个Ruby项目，由若干gems组成。因此本地需要配置Ruby环境才可以运行。在Mac系统中，是自带Ruby的。使用命令<code>Ruby -v</code>查看当前版本。</p>
<pre><code>➜  ~ Ruby -v
ruby 2.3.7p456 (2018-03-28 revision 63024) [universal.x86_64-darwin18]
➜  ~
</code></pre>
<p>如果系统版本过低，导致系统自带的ruby版本太低，是无法安装<code>cocoapods</code>的，需要升级ruby才可以。我们通常使用RVM(Ruby Verssion Manager)来管理ruby的版本。</p>
<h6 id="5321-安装rmv">5.3.2.1、安装rmv</h6>
<pre><code>➜  ~ curl -L get.rvm.io | bash -s stable
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   194  100   194    0     0     63      0  0:00:03  0:00:03 --:--:--    63
100 24168  100 24168    0     0   5638      0  0:00:04  0:00:04 --:--:-- 3034k
Downloading https://github.com/rvm/rvm/archive/1.29.8.tar.gz
Downloading https://github.com/rvm/rvm/releases/download/1.29.8/1.29.8.tar.gz.asc
Found PGP signature at: 'https://github.com/rvm/rvm/releases/download/1.29.8/1.29.8.tar.gz.asc',
but no GPG software exists to validate it, skipping.
Installing RVM to /Users/mali/.rvm/
    Adding rvm PATH line to /Users/mali/.profile /Users/mali/.mkshrc /Users/mali/.bashrc /Users/mali/.zshrc.
    Adding rvm loading line to /Users/mali/.profile /Users/mali/.bash_profile /Users/mali/.zlogin.
Installation of RVM in /Users/mali/.rvm/ is almost complete:

  * To start using RVM you need to run `source /Users/mali/.rvm/scripts/rvm`
    in all your open shell windows, in rare cases you need to reopen all shell windows.
Thanks for installing RVM 🙏
Please consider donating to our open collective to help us maintain RVM.

👉  Donate: https://opencollective.com/rvm/donate


➜  ~ source ~/.bashrc
➜  ~ source ~/.bash_profile
➜  ~
</code></pre>
<h6 id="5322-rvm的基本使用">5.3.2.2、rvm的基本使用</h6>
<p><strong>查看rvm版本</strong></p>
<pre><code>➜  ~ rvm -v
rvm 1.29.8 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io]
➜  ~
</code></pre>
<p><strong>查看可安装的ruby版本</strong></p>
<pre><code>➜  ~ rvm list known
</code></pre>
<p><strong>安装一个ruby版本，我一般安装最新的</strong></p>
<pre><code>➜  ~ rvm install 2.6.3
Searching for binary rubies, this might take some time.
No binary rubies available for: osx/10.14/x86_64/ruby-2.6.3.
Continuing with compilation. Please read 'rvm help mount' to get more information on binary rubies.
Checking requirements for osx.
Certificates bundle '/usr/local/etc/openssl@1.1/cert.pem' is already up to date.
Requirements installation successful.
Installing Ruby from source to: /Users/mali/.rvm/rubies/ruby-2.6.3, this may take a while depending on your cpu(s)...
ruby-2.6.3 - #downloading ruby-2.6.3, this may take a while depending on your connection...
** Resuming transfer from byte position 7135232
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 7201k  100 7201k    0     0  22621      0  0:05:25  0:05:25 --:--:-- 18318
ruby-2.6.3 - #extracting ruby-2.6.3 to /Users/mali/.rvm/src/ruby-2.6.3 - please wait
ruby-2.6.3 - #configuring - please wait
ruby-2.6.3 - #post-configuration - please wait
ruby-2.6.3 - #compiling - please wait
ruby-2.6.3 - #installing - please wait
ruby-2.6.3 - #making binaries executable - please wait
ruby-2.6.3 - #downloading rubygems-3.0.4
ruby-2.6.3 - #extracting rubygems-3.0.4 - please wait
ruby-2.6.3 - #removing old rubygems - please wait
$LANG was empty, setting up LANG=en_US.US-ASCII, if it fails again try setting LANG to something sane and try again.
ruby-2.6.3 - #installing rubygems-3.0.4 - please wait
ruby-2.6.3 - #gemset created /Users/mali/.rvm/gems/ruby-2.6.3@global
ruby-2.6.3 - #importing gemset /Users/mali/.rvm/gemsets/global.gems - please wait
ruby-2.6.3 - #generating global wrappers - please wait
ruby-2.6.3 - #gemset created /Users/mali/.rvm/gems/ruby-2.6.3
ruby-2.6.3 - #importing gemsetfile /Users/mali/.rvm/gemsets/default.gems evaluated to empty gem list
ruby-2.6.3 - #generating default wrappers - please wait
ruby-2.6.3 - #adjusting #shebangs for (gem irb erb ri rdoc testrb rake).
Install of ruby-2.6.3 - #complete
Ruby was built without documentation, to build it run: rvm docs generate-ri
</code></pre>
<p><strong>设置默认版本</strong></p>
<pre><code>➜  ~ rvm use 2.6.3 --default
Using /Users/mali/.rvm/gems/ruby-2.6.3
➜  ~
</code></pre>
<p><strong>更换国内源<code>https://gems.ruby-china.com/</code></strong><br>
由于墙的存在，因此默认的源是非常非常慢的，需要切换的国内的镜像源。</p>
<pre><code>// 移除自带源，因为国内被墙了
➜  ~ gem sources --remove https://rubygems.org/
https://rubygems.org/ removed from sources
➜  ~


//添加国内镜像源
➜  ~ gem source -a https://gems.ruby-china.com/
https://gems.ruby-china.com/ added to sources
➜  ~


// 查看是否更换成功
➜  ~ gem sources -l
*** CURRENT SOURCES ***

https://gems.ruby-china.com/
➜  ~
</code></pre>
<h6 id="5323-安装cocoapods">5.3.2.3、安装<code>cocoapods</code></h6>
<pre><code>// 安装cocoapods
➜  ~ sudo gem install cocoapods
Password:
Fetching thread_safe-0.3.6.gem
Fetching concurrent-ruby-1.1.5.gem
Fetching i18n-0.9.5.gem
Fetching activesupport-4.2.11.1.gem
Fetching fuzzy_match-2.0.4.gem
Fetching tzinfo-1.2.5.gem
Fetching nap-1.1.0.gem
Fetching cocoapods-core-1.7.2.gem
Fetching claide-1.0.2.gem
Fetching cocoapods-deintegrate-1.0.4.gem
Fetching cocoapods-downloader-1.2.2.gem
Fetching cocoapods-plugins-1.0.0.gem
Fetching cocoapods-search-1.0.0.gem
Fetching cocoapods-stats-1.1.0.gem
Fetching netrc-0.11.0.gem
Fetching cocoapods-trunk-1.3.1.gem
Fetching cocoapods-try-1.1.0.gem
Fetching molinillo-0.6.6.gem
Fetching atomos-0.1.3.gem
Fetching CFPropertyList-3.0.0.gem
Fetching colored2-3.1.2.gem
Fetching nanaimo-0.2.6.gem
Fetching xcodeproj-1.10.0.gem
Fetching escape-0.0.4.gem
Fetching fourflusher-2.3.1.gem
Fetching gh_inspector-1.1.3.gem
Fetching ruby-macho-1.4.0.gem
Fetching cocoapods-1.7.2.gem
Successfully installed thread_safe-0.3.6
Successfully installed tzinfo-1.2.5
Successfully installed concurrent-ruby-1.1.5
Successfully installed i18n-0.9.5
Successfully installed activesupport-4.2.11.1
Successfully installed nap-1.1.0
Successfully installed fuzzy_match-2.0.4
Successfully installed cocoapods-core-1.7.2
Successfully installed claide-1.0.2
Successfully installed cocoapods-deintegrate-1.0.4
Successfully installed cocoapods-downloader-1.2.2
Successfully installed cocoapods-plugins-1.0.0
Successfully installed cocoapods-search-1.0.0
Successfully installed cocoapods-stats-1.1.0
Successfully installed netrc-0.11.0
Successfully installed cocoapods-trunk-1.3.1
Successfully installed cocoapods-try-1.1.0
Successfully installed molinillo-0.6.6
Successfully installed atomos-0.1.3
Successfully installed CFPropertyList-3.0.0
Successfully installed colored2-3.1.2
Successfully installed nanaimo-0.2.6
Successfully installed xcodeproj-1.10.0
Successfully installed escape-0.0.4
Successfully installed fourflusher-2.3.1
Successfully installed gh_inspector-1.1.3
Successfully installed ruby-macho-1.4.0
Successfully installed cocoapods-1.7.2
Parsing documentation for thread_safe-0.3.6
Installing ri documentation for thread_safe-0.3.6
Parsing documentation for tzinfo-1.2.5
Installing ri documentation for tzinfo-1.2.5
Parsing documentation for concurrent-ruby-1.1.5
Installing ri documentation for concurrent-ruby-1.1.5
Parsing documentation for i18n-0.9.5
Installing ri documentation for i18n-0.9.5
Parsing documentation for activesupport-4.2.11.1
Installing ri documentation for activesupport-4.2.11.1
Parsing documentation for nap-1.1.0
Installing ri documentation for nap-1.1.0
Parsing documentation for fuzzy_match-2.0.4
Installing ri documentation for fuzzy_match-2.0.4
Parsing documentation for cocoapods-core-1.7.2
Installing ri documentation for cocoapods-core-1.7.2
Parsing documentation for claide-1.0.2
Installing ri documentation for claide-1.0.2
Parsing documentation for cocoapods-deintegrate-1.0.4
Installing ri documentation for cocoapods-deintegrate-1.0.4
Parsing documentation for cocoapods-downloader-1.2.2
Installing ri documentation for cocoapods-downloader-1.2.2
Parsing documentation for cocoapods-plugins-1.0.0
Installing ri documentation for cocoapods-plugins-1.0.0
Parsing documentation for cocoapods-search-1.0.0
Installing ri documentation for cocoapods-search-1.0.0
Parsing documentation for cocoapods-stats-1.1.0
Installing ri documentation for cocoapods-stats-1.1.0
Parsing documentation for netrc-0.11.0
Installing ri documentation for netrc-0.11.0
Parsing documentation for cocoapods-trunk-1.3.1
Installing ri documentation for cocoapods-trunk-1.3.1
Parsing documentation for cocoapods-try-1.1.0
Installing ri documentation for cocoapods-try-1.1.0
Parsing documentation for molinillo-0.6.6
Installing ri documentation for molinillo-0.6.6
Parsing documentation for atomos-0.1.3
Installing ri documentation for atomos-0.1.3
Parsing documentation for CFPropertyList-3.0.0
Installing ri documentation for CFPropertyList-3.0.0
Parsing documentation for colored2-3.1.2
Installing ri documentation for colored2-3.1.2
Parsing documentation for nanaimo-0.2.6
Installing ri documentation for nanaimo-0.2.6
Parsing documentation for xcodeproj-1.10.0
Installing ri documentation for xcodeproj-1.10.0
Parsing documentation for escape-0.0.4
Installing ri documentation for escape-0.0.4
Parsing documentation for fourflusher-2.3.1
Installing ri documentation for fourflusher-2.3.1
Parsing documentation for gh_inspector-1.1.3
Installing ri documentation for gh_inspector-1.1.3
Parsing documentation for ruby-macho-1.4.0
Installing ri documentation for ruby-macho-1.4.0
Parsing documentation for cocoapods-1.7.2
Installing ri documentation for cocoapods-1.7.2
Done installing documentation for thread_safe, tzinfo, concurrent-ruby, i18n, activesupport, nap, fuzzy_match, cocoapods-core, claide, cocoapods-deintegrate, cocoapods-downloader, cocoapods-plugins, cocoapods-search, cocoapods-stats, netrc, cocoapods-trunk, cocoapods-try, molinillo, atomos, CFPropertyList, colored2, nanaimo, xcodeproj, escape, fourflusher, gh_inspector, ruby-macho, cocoapods after 15 seconds
28 gems installed

// 安装本地库，需要等待很长时间
➜  ~ pod setup
Ignoring executable-hooks-1.6.0 because its extensions are not built. Try: gem pristine executable-hooks --version 1.6.0
Ignoring gem-wrappers-1.4.0 because its extensions are not built. Try: gem pristine gem-wrappers --version 1.4.0
Setting up CocoaPods master repo
  $ /usr/bin/git -C /Users/mali/.cocoapods/repos/master fetch origin --progress
  remote: Enumerating objects: 11494, done.
  remote: Counting objects: 100% (11494/11494), done.
  remote: Compressing objects: 100% (165/165), done.
  remote: Total 44594 (delta 11354), reused 11424 (delta 11313), pack-reused 33100
  Receiving objects: 100% (44594/44594), 5.01 MiB | 36.00 KiB/s, done.
  Resolving deltas: 100% (30150/30150), completed with 4479 local objects.
  From https://github.com/CocoaPods/Specs
     c68db42388d..082ed90868f  master     -&gt; origin/master
   + a1c937ec508...02443419999 indexes    -&gt; origin/indexes  (forced update)
   * [new branch]              netlify    -&gt; origin/netlify
  $ /usr/bin/git -C /Users/mali/.cocoapods/repos/master rev-parse --abbrev-ref HEAD
  master
  $ /usr/bin/git -C /Users/mali/.cocoapods/repos/master reset --hard origin/master
  Checking out files: 100% (4657/4657), done.
  HEAD is now at 082ed90868f [Add] WrapModel 1.0.8
Setup completed
➜  ~
</code></pre>
<h6 id="5324-cocoapods常用命令">5.3.2.4、<code>cocoapods</code>常用命令</h6>
<pre><code>// 当前使用 pod 版本
pod –version
// 更新到最新稳定版本
sudo gem install cocoapods
// 安装指定版本
sudo gem install cocoapods -v [版本号]
// 移除 CocoaPods，如果你安装多个，会列出一个 list 让你选择删除那个。如果只安装一个，也会给你提示，问你是否确定删除。
sudo gem uninstall cocopods
// 移除指定版本
sudo gem uninstall cocopods -v [版本号]
// 初始化项目`cocoapods`
pod init
// Podfile 中添加组件
pod ‘’
// 安装组件
pod install
// 安装组件的详细过程
pod install –verbose
// 更新某一组件
pod update [组件名]
// 更新本地依赖
pod repo update
</code></pre>
<h4 id="54-git-svn">5.4、git &amp;&amp; svn</h4>
<h5 id="541-svn">5.4.1、svn</h5>
<p><code>mac</code>是自带svn的，直接使用命令行可能是最便捷的方式了。如果需要GUI，可以使用cornerStore。</p>
<h5 id="542-git">5.4.2、git</h5>
<p>通过<code>homebrew</code>安装git，直接使用命令行。如果需要GUI，可以使用sourcetree。</p>
<h4 id="55-蒲公英">5.5、<a href="https://www.pgyer.com/">蒲公英</a></h4>
<p>由于iOS系统的特殊性，在测试阶段，真机测试是个非常麻烦的。蒲公英提供了一种相对简单的方式，简化了我们的流程。</p>
<h4 id="56-charles">5.6、<a href="https://www.charlesproxy.com/">Charles</a></h4>
<p><code>Charles</code>是一款Mac上常用的抓包工具，在移动开发过程中，我们常常需要调试与服务端的网络通讯协议，截取网络封包。<code>Charles</code>是通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问都通过它来完成，从而实现了网络封包的抓取。</p>
<h4 id="57-app-icon-gear-prepo">5.7、<a href="%5Bhttps://apps.apple.com/cn/app/app-icon-gear-xcode%E5%9B%BE%E6%A0%87%E8%B5%84%E6%BA%90%E5%8A%A9%E6%89%8B/id989646576?mt=12%5D(https://apps.apple.com/cn/app/app-icon-gear-xcode%E5%9B%BE%E6%A0%87%E8%B5%84%E6%BA%90%E5%8A%A9%E6%89%8B/id989646576?mt=12)">app icon gear</a> || <a href="https://apps.apple.com/cn/app/prepo/id476533227?l=en&amp;mt=12">prepo</a></h4>
<p>这两款软件都是帮助生成APP开发中需要的icon的软件。当你对公司UI绝望的时候，这类软件会让你重获新生。</p>
<h3 id="6-其他好用的开发工具">6、其他好用的开发工具</h3>
<h4 id="61-homebrew">6.1、homebrew</h4>
<p>homebrew是一款 Mac OS 系统下的第三方软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多使用的功能。homebrew会将软件包安装到独立目录，并将其文件symlink（软连接）到 /usr/local/Cellar 路径下。</p>
<h5 id="611-安装homebrew">6.1.1、安装homebrew</h5>
<pre><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<h5 id="612-卸载homebrew">6.1.2、卸载homebrew</h5>
<pre><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;  
</code></pre>
<h5 id="613-homebrew常用命令及使用">6.1.3、homebrew常用命令，及使用。</h5>
<pre><code>brew help                  //帮助
brew update                //更新homebrew软件，把所有的Formula目录更新，并且会对本机已经安装并有更新的软件标明。
brew upgrade               //更新homebrew软件，更新所有安装的Formula。
brew upgrade [Formula]     //更新homebrew软件，更新某个Formula。
brew info [FORMULA...]     //展示某个Formula的信息。
brew search [TEXT|/REGEX/] //搜索某个Formula，支持正则表达式。
brew install [FORMULA]     //安装Formula。
brew uninstall [FORMULA]   //卸载Formula。
brew list                  //展示目前安装的软件。
</code></pre>
<h5 id="614-常用formula">6.1.4、常用Formula</h5>
<p><strong>版本管理：git</strong></p>
<pre><code>malideMacBook-Pro:~ mali$ brew install git
</code></pre>
<p><strong>预览插件( <a href="https://github.com/sindresorhus/quick-look-plugins">quick-look-plugins</a> )</strong></p>
<blockquote>
<p>qlcolorcode        预览代码时代码高亮。<br>
qlstephen          支持预览没有后缀的文本文件。<br>
qlmarkdown         预览markdown文件的渲染效果。<br>
quicklook-json     对json文件的格式化和高亮预览。<br>
betterzip          预览压缩文件内部的内容，并支持自定义解压缩的行为；收费。<br>
qlimagesize        图片预览时展示分辨率和大小。<br>
webpquicklook      支持预览webP格式的图片。<br>
qlvideo            预览更多格式的视频文件。<br>
provisionql        可以预览.app或者.ipa文件的程序。<br>
quicklookapk       预览安卓.apk的程序。</p>
</blockquote>
<pre><code>malideMacBook-Pro:~ mali$ brew cask install qlcolorcode qlstephen qlmarkdown quicklook-json qlimagesize webpquicklook qlvideo provisionql quicklookapk
</code></pre>
<p><strong>下载利器：wget</strong></p>
<pre><code>malideMacBook-Pro:~ mali$ brew install wget
</code></pre>
<h4 id="62-iterm2-oh-my-zsh">6.2、iterm2 + oh my zsh</h4>
<p>作为程序员，会有非常多的场景用到命令行。macOS系统自带的terminal有时候不是很顺手，我们可以选择另外一个更好用的命令行工具 <strong>iterm2</strong>。可以使用homebrew安装。</p>
<pre><code>malideMacBook-Pro:Downloads mali$ brew cask install iterm2
Updating Homebrew...
==&gt; Satisfying dependencies
==&gt; Downloading https://iterm2.com/downloads/stable/iTerm2-3_2_9.zip
######################################################################## 100.0%
==&gt; Verifying SHA-256 checksum for Cask 'iterm2'.
==&gt; Installing Cask iterm2
==&gt; Moving App 'iTerm.app' to '/Applications/iTerm.app'.
🍺  iterm2 was successfully installed!
malideMacBook-Pro:Downloads mali$ 
</code></pre>
<p><strong>iterm2</strong> 安装完毕之后，开始安装 <strong><a href="https://ohmyz.sh/">oh my zsh</a></strong>。</p>
<pre><code>//curl安装
malideMacBook-Pro:~ mali$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;

//wget安装
malideMacBook-Pro:~ mali$ sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;
</code></pre>
<h5 id="621-为什么用zsh">6.2.1、为什么用zsh</h5>
<p>zsh和bash都是shell的一种，不过zsh在使用中，更加便利。对我来说，仅仅是zsh的自动补全就足以让我选择用它了。向更进一步了解，可以查看下列文章。<br>
<a href="https://www.zhihu.com/question/21418449">为什么说 zsh 是 shell 中的极品？</a><br>
<a href="https://www.xshell.net/shell/bash_zsh.html">Zsh和Bash，究竟有何不同 坑很深</a></p>
<h5 id="622-为什么用oh-my-zsh">6.2.2、为什么用oh my zsh</h5>
<p>zsh的配置需要花费大量的时间，而 <strong>oh my zsh</strong> 相当于是一个提供了预设个性配置的zsh，大大减少了我们配置的时间，非常推荐使用。<br>
<a href="https://www.jianshu.com/p/d194d29e488c?open_source=weibo_search">oh-my-zsh,让你的终端从未这么爽过</a></p>
<h5 id="623-oh-my-zsh-基本使用">6.2.3、oh my zsh 基本使用</h5>
<pre><code>//查看当前使用的shell
➜  ~ echo $SHELL
/bin/zsh
➜  ~


//查看当前zsh版本
➜  ~ zsh --version
zsh 5.3 (x86_64-apple-darwin18.0)
➜  ~


//切换shell，从bash切换到zsh，需要重启iterm
➜  ~ chsh -s /bin/zsh
Changing shell for mali.
Password for mali:
➜  ~ 


//切换shell，从zsh切换到bash，需要重启iterm
➜  ~ chsh -s /bin/bash
Changing shell for mali.
Password for mali:
➜  ~


//查看当前环境安装了哪些shell
➜  ~ cat /etc/shells
# List of acceptable shells for chpass(1).
# Ftpd will not allow users to connect who are not using
# one of these shells.

/bin/bash
/bin/csh
/bin/ksh
/bin/sh
/bin/tcsh
/bin/zsh
➜  ~


//修改主题
oh my zsh 的配置文件路径是：~/.zshrc
进入配置文件，找到 ZSH_THEME 字段，修改为 ZSH_THEME=&quot;agnoster&quot;。
agnoster主题，需要Powerline字体库的支持。

//从github拉取[Powerline字体库](https://github.com/powerline/fonts)，拉取完成之后，运行install.sh文件安装。
然后设置iterm字体为 Meslo LG S DZ for Powerline 即可。
</code></pre>
<h5 id="624-iterm-基本使用">6.2.4、iterm 基本使用</h5>
<p>恢复原始配置</p>
<pre><code>~ ➤ defaults delete com.googlecode.iterm2
~ ➤
然后重启iterm即可。
</code></pre>
<h4 id="63-ssh-copy-id">6.3、ssh-copy-id</h4>
<p>SSH 是 Secure Shell 的缩写，其实就是远程 Shell 登录。只要能远程登录到某台机器的 Shell 上，大到 Mac 笔记本，小到树莓派和智能路由器，我们就可以上传或下载文件、执行脚本等等，几乎掌握了设备的控制权。一般来说，配置自己的云服务器，都需要ssh登陆。<br>
ssh登陆时，需要制定ip地址和登录名，例如<code>ssh 192.168.1.1@root</code>，就是指登陆ip为192.168.1.1的主机的用户root。ssh协议默认端口为22，不用填写；如果设备为了安全修改了端口为1234，则必须输入，例如<code>ssh -p 1234 192.168.1.1@root</code>。接下来输入密码就可以登陆了。<br>
不过记忆密码是一件非常麻烦的事，好在ssh支持使用RSA的公钥和私钥来验证身份。具体就是指将自己的公钥文件（ ~/.ssh/id_rsa.pub ）的内容复制到目标服务器（ ~/.ssh/authorized_keys ）文件中。这样其实也很繁琐。<br>
<strong>ssh-copy-id</strong> 就是一款简化过程，方便我们使用的工具。<br>
另外，可以通过ssh的配置文件配置来设置云服务器的别名，省去了记忆ip、用户名、端口号的麻烦。基本格式如下</p>
<pre><code>Host malitest
    HostName 192.168.1.1
    User root
    Port 22
    IdentityFile ~/.ssh/id_rsa
</code></pre>
<h4 id="64-dash">6.4、<a href="https://kapeli.com/dash">Dash</a></h4>
<p><strong>Dash</strong> 是一个API文档浏览器。配合 <strong>Alfred</strong> 可以快速查询api。</p>
<p>具体可以查看文章：<a href="https://zhuanlan.zhihu.com/p/40466851">程序员的 API 文档查询利器：Dash</a> 。</p>
<h3 id="7-自我提升">7、自我提升</h3>
<h4 id="71-腾讯课堂">7.1、腾讯课堂</h4>
<h4 id="72-欧路词典">7.2、欧路词典</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信支付]]></title>
        <id>https://codermali.github.io/malideLibrary.github.io//post/wei-xin-zhi-fu</id>
        <link href="https://codermali.github.io/malideLibrary.github.io//post/wei-xin-zhi-fu">
        </link>
        <updated>2019-06-21T09:21:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="微信支付">微信支付</h3>
<h5 id="接入微信支付首先需要注册微信商户号">接入微信支付首先需要注册微信商户号。</h5>
<ol>
<li>打开 <a href="https://pay.weixin.qq.com/index.php/core/home/login?return_url=%2F">微信支付</a> 首页，选择「成为商家，选择「注册微信支付商户号」，然后绑定管理员微信。</li>
<li>完成以上操作后，进入申请流程。分为三个步骤：创建申请单，填写商户信息，确认提交。
<ul>
<li>创建申请单中，需要输入管理员的各种信息；</li>
<li>填写商户信息过程中，可以选择四个类型：个体工商户，企业，党政、机关及事业单位，其他组织。我选择的是企业，需要三证合一的营业执照，法人身份证，对公账户，经营信息以及结算规则。
<ul>
<li>在这个过程中，我碰到一个问题。在填写经营信息时，我选择的经营场景是APP，微信提示需要提供APP首页截图、尾页截图、应用内截图、支付页截图各1张。但是目前我们的APP是并没有开发完成。因此，只能使用其他方式先注册，在APP开发完成之后，再进行更换。</li>
</ul>
</li>
<li>确认提交，主要是对提交资料的一个确认，并提交审核。</li>
</ul>
</li>
<li>资料提交成功之后，需要进行账户验证。有两种方式：
<ol>
<li>使用法人微信认证。</li>
<li>使用公账汇款。
<ul>
<li>使用公账汇款，会有延迟。</li>
</ul>
</li>
</ol>
</li>
<li>账户验证通过之后，需要等待微信审核结果。我们公司公账是招商银行账户，48小时内有结果。<a href="http://kf.qq.com/faq/161223BfIRVz161223zA3ieY.html">点击查看具体</a></li>
</ol>
<h3 id="支付宝支付">支付宝支付</h3>
]]></content>
    </entry>
</feed>